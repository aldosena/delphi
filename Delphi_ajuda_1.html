<HTML>
<HEAD>
<TITLE>Códigos para Delphi</TITLE>
<style type="text/css">
<!--
body,td,th {
font-family: Arial, Helvetica, sans-serif;
font-size: 14px;
}

h1{
	font: 10px;
	color: Tomato;
	font-weight: normal;
}

h2{
	font: 9px;
	color: orange;
	font-weight: normal;
}

i{
    color: green;
}
-->
</style>
</HEAD>
<BODY>
  <p><a href="#instala"> Instalando Componente </a></p>
  <p><a href="#config"> Configurações no Delphi </a></p>
  <p><a href="#arqtexto"> Arquivo de Texto </a></p>

<h1> Evitar que a aplicação trave </h1>
<p><i>trave, travamento, erro </i> </p>
<p>Exemplo <br>
Table1.First; <br>
while not (Table1.Eof) do<br>
 begin 
   lbStatus.Caption := 'Processando registro...'; <i> // exibimos mensagem </i><br>
   Application.ProcessMessages; <i>// chamados o método que força o SO a desenha janela </i><br>
   Table1.Next; <i> // pula para o próximo registro da tabela end; </i><br>
</p>



<h1> Page Control </h1>
<p>Para exibir ou ocultar um pagecontrol </p>
<p>PageControl1.Pages[0].TabVisible := False;<br>
ou <br>
  PageControl1.Pages[0].TabVisible := True;</p>
    
<h1>Pousa</h1>
<p>Para parar 1 segundo use : SLEEP(1000);<br />
Para parar 10 segundos use : SLEEP(10000);</p>

<h1> Array </h1>
<p>
  In XE7 you can declare a dynamic array constant like this:<br>
const<br>
  MyArray: TArray<String> = ['First','Second','Third'];
</p>
<p> vetor: array  [0..2] of string = (´A´,´B´,´C´); </p>

<p>Codigo do botão para salvar:<br />
  if (DM.tbLink.State in [dsEdit, dsInsert]) then	<br />
      DM.tbLink.Post;	</p>

<h1>Encriptar</h1>
<p>c := GetSha1(d);<br />
<em>Os dados vão em letras maiúsculas</em></p>

<p>Encriptar usando SHA1 pois tem compatibilidade com o php</p>

<p>uses..... colocar......IdHashSHA		</p>
<pre>
function GetSha1(Text: String): String;
var
  Sha1: TIdHashSHA1;
begin
  Sha1:= TIdHashSHA1.Create;
  try
      Result:= Sha1.HashStringAsHex(Text);
  finally
      Sha1.Free;
  end;
end;
</pre>

<p><strong>Executar uma .DLL</strong></p>
No onCreate do programa: <br />
<em>Para o programa ler a dll que está na pasta</em><br />
vs := ExtractFilePath(ParamStr (0));<br />
WinExec(PAnsiChar('Command.com /c SET PATH= ' + vs),0);</p>
 
<h1>Timer</h1>
<p>1 segundo é igual a 1000 milésimos<br />
1000 x 60 = 60000 <br />
1 minuto é igual a 60000 milésimos! <br />
60000 x 30 = 1800000 <br />
30 minutos é igual a 1800000 milésimos. </p>

<h1>Trabalhando com strings</h1>
<p>concatenar</p>
<pre>
var
  s : TStringBuilder;
begin
  s := TstringBuilder.create('aldo');
  s.Append(' ');
  s.Append('sena');
end;
showmessage(s.ToString);

-- outro:
  s.Append('dia').Append('mes').Append('ano');

** remove um caracter apartir da pos. 1
s.Remove(1.1);
</pre>]
<p>Delete(vS, 2,1); <i>// delete da variável vS, na segunda posição, 1 caractere</i></p>
<p>Insert("z",vS,1); <i>//insere a letra z no começo da string</i></p>
Length(vS); <i>Retorna o número de caracteres de uma string</i><br>
Lowercase( 'SORTE' ); <i>// tranformar para 'sorte'</i><br>
UpperCase( 'sorte' ); <i>// tranformar para 'SORTE'</i><br>
Pos('a','Pernambuco'); <i>// retorna a posição de uma string dentro de uma outra string. valor 5</i><br>
Str(vN,vS); <i>//Converte um valor inteiro ou real(vN)para uma string(vS)</i><br>
VAL - Esta rotina extrai o valor numérico ( tipo real ou integer ) de uma String;<br>
Sua sintaxe é :<br>
Val ( S ; var v ; var Code : integer );<br>
Observe o exemplo abaixo :<br>
Var<br>
N, C : integer ;<br>
Begin<br>
Val ( Edit1.Text, N, C ) ;<br>
Button1. Top := N ;<br>
End ;<br>
// Se a variável C tiver valor diferente de 0 significa que ouve erra na conversção. ( ex : O texto do Edit não é um número intéiro válido )<br>
<br>
Format<br>
//Para coloca zeros a esquerda dos números encontrados.
%5 o valor da variável inteira "VNum"
// .5d por que são 5 caracteres
Edit1.text:= Format('%5.5d',[VNum]);
<br>
//Colocar zeros a esquerda de um valor inteiro digitado no Edit<br>
Edit1.Text := FormatFloat('000000',StrToInt(Edit1.Text));<br>
Formatando com estilo de moeda
//Formatando um valor Real
Edit1.Text := FormatFloat('#,##0.00',vSalario);
//Formatando uma String
Edit1.Text := FormatFloat('#,##0.00',StrToFloat(Edit1.Text));
Obs- (#) Cerquilha, para números obcionais. (,) Ponto para separar milhar. (.) Virgula para separar casas decimais.
<br>
//A linha abaixo exibe em um label, seu top. Misturando String do Inteiro
Label1.Caption := Format('O top deste label é %d',[Label1.top]);
//Lendo uma variável inteira
Label.Caption := Format ('O número guardado é : %d, [i]);
// Para exibir o valor Hexadecimal de uma variável integer(i)
Label1.Caption := Format('$%x',[i]);
<br>
&Delete - Ex:
Delete(MyString) // deleta da variável MyString, na segunda posição, um caractere
Insert - Ex:
Insert ('z',MyString,1) // Insere a letra z no começo da String
InttoStr - Ex:
MyString := InttoStr(Shape1.top)<i>//A variável MyString recebe o valor top do componente Shape1</i><br />

<p><strong>Mensagens</strong></p>
<p>if not(MessageDlg('Quer sair do programa',mtInformation,[mbYes,mbNo],0) = mrYes) then<br />
Form1.close;</p>

<p>if (Application.MessageBox('Confirmar Exclusão','Atenção',mb_YesNo + mb_iconQuestion) = idYes) then</p>

<p>If Application.MessageBox('Confirma Exclusão?','ATENÇÃO',MB_ICONEXCLAMATION + MB_YESNO) = IDYES Then<br />
Tb_Alunos.Delete;</p>

<p><h1>INPUTBOX</h1>
<i>//Exibe uma caixa de diálogo onde digitamos um valor que será exibido em um label</i><br>
Label1.Caption := InputBox('digite','integer','');<br>
<br>
<i>//Sensível à maiúsculas e minúsculas. Veja abaixo dois exemplos.</i><br>
Exemplo1<br>
procedure TForm1.Button3Click(Sender: TObject);<br>
var<br>
NS: string;<br>
clickOK: Boolean; // clickok foi inventado<br>
begin<br>
NS := 'Nome fixo';<br>
Label1.Caption := NS;<br>
clickOK := InputQuery('Input Box', 'digite', NS);<br>
if clickOK then<br>
Label1.Caption := 'The new string is ''' + NS + '''';<br>
end;<br>
<br>
&INPUTQUERY<br>
inputQuery( ' ver ' , ' senha ' , r );<br>
<br>
&Tratando Erros<br>
Deletando um registro<br>
try<br>
DMAgenda.tbAgenda.Delete;<br>
except<br>
On E:EDBEngineError do<br>
ShowMessage('Registro em uso por outro USUÁRIO. Exclusão Cancelada';<br>
end;<br>
<br>
&Datas Inválidas
Try<br>
StrtoDate(Edit1.text);<br>
except<br>
on EconvertError do<br>
ShowMessage('Data Inválida');<br>
end;<br>
<br>

<p>Centralizar um componete<br />
No evento OnResize digite:<br />
Toda vez que o form sor redimencionado, o Button ficara no centro<br />
Button1.Top := Form1.ClientHeight div 2 - Button1.Height div 2;<br />
Button1.Left := Form1.ClientWidth div 2 - Button1.Width div 2;<br />
</p>

<p><b>Senhas</b><br />
Colocar senha numa tabela Paradox //...e retirar em tempo de execução:<br />
Session.AddPassword('Senha-Da-Tabela');<br />
...<br />
Session.RemovePassword;<br />
outra opção...<br >
Session.AddPassword('Senha');<br>
Table1.Active := True;<br>
// vincule o Table1 ao Session><br>
</p>

<p>Form sempre na frente - Janela sempre no topo:<br />
fm_Permite.FormStyle := fsStayOnTop;</p>

<h1># TECLADO</h1>

<p>#0=Null #8=Backspace #13=Enter #27=Escape #32=Espaço #127=Delete </p>

<p>//fazer o Enter, substituir o Tab... <br>
if key = #13 then <br>
Edit1.SetFocus; // o Edit recebe o foco </p>

<p> loque no form: keypreview = true. No ONKEYDOWN, digite:<br>
if (Key= VK_RETURN) or (Key= VK_DOWN) then<br>
begin<br>
Key := 0;<br>
Perform(WM_NEXTDLGCTL, 0, 0);<br>
end<br>
else<br>
if (Key= VK_UP) then<br>
begin<br>
Key := 0;<br>
Perform(WM_NEXTDLGCTL, 1, 0);<br>
end;<br>
//outra opção<br>
if Key = VK_RETURN then Perform(Wm_NextDlgCtl,0,0);<br>
<br>
<p>Fechar janela</p>
<p><em>if Key = vk_escape then close;</em></p>

//fazer o Enter, substituir o Tab...(II)<br>
SelectNext(ActiveControl,true,true);// joga o foco no proximo componente<br>
<br>
///Cancelando uma tecla<br>
if (Key = 'A') or (Key = 'a') then<br>
Key := #0;<br>
<br>
Levar o foco para o componente anterior<br>
// No evento OnKeyDown digite:<br>
if Key = (Vk_Up) then<br>
Perform(Wm_NextDlgCtl,1,0);<br>
<br>
Caracteres especiais<br>
// declare uma constante com os caracteres especiais... Const<br>
chrEspecial : Set of Char =['@','#','$','%'];<br>
//no evento OnKeyPress, digite:<br>
If key in ChrEspecial then<br>
ShowMessage('esta letra é especial');<br>
<br>
<b>// Para digitar maiúsculas...</b><br>
Key := Upcase(Key); //colocar no evento OnKeyPress de um Edit<br>
<br>
<br>
Emular o pressionamento de um botão<br>
If (key = VK_F1) then btnAjuda.Onclick(Self);//no evento OnKeyPress<br>
<br>
Para desabilitar o CTRL+ALT+DEL e ALT+TAB<br>
Var<br>
numero: integer;<br>
begin<br>
SystemParametersInfo(97,Word(true),@numero,0);<br>
end;<br>
{ Para habilitar é só chamar a mesma função com Word(false) }<br>
<br><br>
+++loque no form: keypreview = true. No ONKEYDOWN, digite:<br>
if (Key= VK_RETURN) or (Key= VK_DOWN) then<br>
begin<br>
Key := 0;<br>
Perform(WM_NEXTDLGCTL, 0, 0);<br>
end<br>
else<br>
if (Key= VK_UP) then<br>
begin<br>
Key := 0;<br>
Perform(WM_NEXTDLGCTL, 1, 0);<br>
end;<br>
//outra opção<br>
if Key = VK_RETURN then Perform(Wm_NextDlgCtl,0,0);<br>
<br>
//fazer o Enter, substituir o Tab...(II)<br>
SelectNext(ActiveControl,true,true);// joga o foco no proximo componente<br>
<br>
///Cancelando uma tecla<br>
if (Key = 'A') or (Key = 'a') then<br>
Key := #0;<br>
<br>
Levar o foco para o componente anterior<br>
// No evento OnKeyDown digite:<br>
if Key = (Vk_Up) then<br>
Perform(Wm_NextDlgCtl,1,0);<br>
<br>
Caracteres especiais<br>
// declare uma constante com os caracteres especiais... Const<br>
chrEspecial : Set of Char =['@','#','$','%'];<br>
//no evento OnKeyPress, digite:<br>
If key in ChrEspecial then<br>
ShowMessage('esta letra é especial');<br>
<br>
<b>// Para digitar maiúsculas...</b><br>
Key := Upcase(Key); //colocar no evento OnKeyPress de um Edit<br>
<br>
<br>
Emular o pressionamento de um botão<br>
If (key = VK_F1) then btnAjuda.Onclick(Self);//no evento OnKeyPress<br>
<br>
Para desabilitar o CTRL+ALT+DEL e ALT+TAB<br>
Var<br>
numero: integer;<br>
begin<br>
SystemParametersInfo(97,Word(true),@numero,0);<br>
end;<br>
{ Para habilitar é só chamar a mesma função com Word(false) }<br>
<br><br>
<p>- fim do teclado </p>
<hr />


<h1># Gráfico</h1>
Grafic1.Title.Text.Clear<br>
Grafic1.Title.Text.Add('Alunos por sexo');<br>
With Series1 do<br>
Begin<br>
  Add( 40, 'Pencil' , clRed ) ;<br>
  Add( 60, 'Paper', clBlue ) ;<br>
  Add( 30, 'Ribbon', clGreen ) ;<br>
end;<br>
<br>

<p># For in<br />
<i>Faz o look igual ao for</i></p>
<pre>
for letra in palavra do
begin
   seu codigo
end;
</pre>
+++

<p>Comentar várias linhas<br />
selecione e depois: ctrl + ;</p>
   
<p>Trabalhando com a Guia Dialogs</p>

<h1>SaveDialog</h1>
<p>if SaveDialog1.Execute then<br />
begin<br />
Memo1.Lines.SaveToFile (SaveDialog1.FileName); // pode ser um RichEdit<br />
end;</p>

<h1>OpenDialog</h1>
<pre>
OpenDialog1.FileName:= ''; // só por garantia
s := ExtractFilePath(ParamStr(0)); // pego o diretório do exe
OpenDialog1.InitialDir := s; // seto para o diretório que eu quero
if (OpenDialog1.Execute) then
  Memo1.Lines.LoadFromFile(OpenDialog1.FileName) ; // poderia ser um RichEdit
</pre>

<h1>OpenPictureDialog</h1>
<pre>
if OpenPictureDialog1.Execute then
  image1.Picture.LoadFromFile (OpenPictureDialog1.fileName) ; // carrega uma imagem no componente
</pre>

FontDialog<br>
if FontDialog1.Execute then<br>
begin<br>
Memo1.Font := Font;// poderia ser um RichEdit<br>
end;<br>
ou...<br>
with FontDialog1 dobr> begin<br>
Font := Label1.Font;<br>
if Execute then<br>
Label1.Font := Font;<br>
end;<br>
colordialog<br>
if colordialog1.Execute then<br>
begin<br>
with ColorDialog1 do<br>
begin<br>
Color := Label1.Color;<br>
ou...<br>
if Execute then<br>
Label1.Color := Color;<br>
end;<br>
RichEdit.Color := Color;<br>
end;<br>
PrintDialog<br>
PrintDialog1.Execute;<br>
<br>
<hr />

<h1># Data e Hora - Tempo - Time - Day - Week</h1>

<p><i>Pegar a data de um servidor sql</i></p>
<pre>
  qypermite.Active := false;
  qypermite.SQL.Clear;
  qypermite.SQL.Add('select now() as bomdia');
  qypermite.Active := true;
  a := qypermite.FieldByName('bomdia').Value;
  showMessage(formatdatetime('dd/mm/yy',a));
</pre>

<p><i>//Formatando uma Data:</i>
dbedit1.text:=formatDateTime('dd/mm/yyyy hh:nn',now);</p>

DateToStr(Date) ==> 21/09/01<br>
TimeToStr(Time) ==> 11:50:00<br>
FormatDateTime('d',Date); ==>21<br>
FormatDateTime('d/m/y',Date);==> 21/9/01<br>
FormatDateTime('dd/mm/yy',Date); ==>21/09/01<br>
FormatDateTime('ddd/dd/mm/yy',Date); ==> Sex/05/09/01<br>
FormatDateTime('dddd/dd/mmmm/yyyy',Date); ==> Sexta-feira/Setembro/1999<br>
FormatDateTime('ddddd',Date); ==> 05/09/99<br>
FormatDateTime('dddddd',Date); ==> Sexta=Feria, 21 de Setembro de 2001<br>
<br>
Furnção DayofWeek(Date); // pega numero do dia da semana..<br>
<br>

%DIA DA SEMANA<br>
<i>Retorna o dia da semana em um inteiro de 1 a 7.</i><br>
function DayOfWeek(Data:TDataTime):Integer;<br>
<i>Data e Hora Atual</i><br>
Ex.:Label1.Caption:= 'Data e Hora Atual' + DateTimeToStr(Now);<br>
<br>

Dias da semana<br>
var<br>
WeekDay : array[1..7] of string;<br>
DayNo : integer;<br>
QDay : string;<br>
begin<br>
weekday[1] := 'domingo<br>
weekday[2] := 'segunda';<br>
weekday[3] := 'ter‡a';<br>
weekday[4] := 'quarta';<br>
weekday[5] := 'quinta';<br>
weekday[6] := 'sexta';<br>
weekday[7] := 'sabado'; DayNo := DayofWeek(Date); // pega numero do dia da semana..<br>
// a mensagem exibe o valor do array na posi‡Æo n. da semana<br>
ShowMessage('O dia ‚: ' + WeekDay[DayNo]);<br>

// Somar uma data<br>
var<br>
Ts1, ts2 : TTimeStamp;<br>
Data1, Data2 : TDateTime;<br>
Dias : Integer;<br>
begin<br>
Date1 := StrtoDate(edit1.text);<br>
Date2 := StrtoDate(edit2.text);<br>
Ts1 := DateTimetoTimeStamp(Data1);<br>
Ts2 := DateTimetoTimeStamp(Data2);<br>
Dias := Ts2.Date - Ts1.Date;<br>
Edit3.Text := InttoStr(Dias);<br>
if Dias > 10 then<br>
ShowMessage('Passaram-se 10 dias');<br>
end;<br>

<br>


O form - Métodos e Propriedades do Form<br>
{ para um formulário aparecer sobre outros sempre }<br>
Form1.formstyle := fsOntop;<br>
<i>{texto em um form}</i><br>
canvas.textout(0,0,'Este texto aparece no form. Top e Left zerados');<br>
<i>{form Elíptico}</i><br>
No evento OnCreate do form, digite:<br>
var hR : THandle;<br>
begin<br>
<br>
Cria uma form de formato elíptico<br>
Obs. Também é bom alterar a propriedade BorderStyle para bsNone. O tamanho da elípse é definido pelo tamanho do form.<br>
hR := CreateEllipticRgn (0,0,Width,Height);<br>
SetWindowRgn (Handle,hR,True);<br>
end;<br>
<br>
Evitar que se tente abrir o mesmo Form, duas vezes<br>
if form1 = nil then // se o form1 ainda não foi criado...<br>
... comandos para criar um form...<br>
//colocar no evento OnClose:<br>
form1 := nil;
<br>
&WINEXEC<br>
<i>//Para executar um outro aplicativo apartir do Delphi</i><br>
If Winexec('c:\windows\calc.exe',sw_shownormal)= 2 then<br>
  showmessage('Arquivo não encontrado');<br>
<br>
<i>//usados no botão fechar dos programas</i><br>
If (fileexists(PChar(vPathName + 'BackUp.exe'))) then<br>
  Winexec(PChar(vPathName + 'BackUp.exe'),SW_SHOWNORMAL);<br>
<br>
para abrir um arquivo<br>
Uses =Shellapi<br>
// vF é o arquivo que eu quero abrir<br>
ShellExecute(Handle, nil, PChar(vF), nil, nil, SW_SHOWNORMAL)<br>
<br>

<p>Verifica se um arquivo existe:</p>
<p>If (fileexists(PChar(vPathName + 'BackUp.exe'))) then<br />
showmessage('Existe');</p>

<p>Pegar o nome do arquivo</p>
<p>var<br />
nomecompleto,nomedoarquivo:string;<br />
begin<br />
   nomecompleto:=´c:\diretorio\teste.exe´;<br />
   nomedoarquivo:=ExtractFileName(nomecompleto);<br />
end;<br />
</p>

<p>Verificar se um diretório existe</p>
<p>Código Inclua na seção uses: FileCtrl, Dialogs<br />
if DirectoryExists('C:MEUSDOCS') then ShowMessage('O diretório existe')<br />
else ShowMessage('O diretório não existe');</p>
 

<h1>Diretório do aplicativo</h1>
<p>No evento OnCreate, digite:</p>
var<br>
PathName: string;<br>
begin<br>
PathName := ExtractFilePath (ParamStr (0));<br>
Label1.Caption := 'Estamos em: '+ PathName;<br>
end;<br>

<p>Alternativa</p>

x := GetCurrentDir; // diretório do executável</p>


<h1>TComboBox</h1>
<p>Para abrir um TComboBox sem clica-lo, digite:<br />
ComboBox1.DroppedDown := True;<br>

<h1>StringList - Lista de strings</h1>

<p>Exemplo:</p>
<pre>
var  
  Texto : TStrings;
begin
 Texto := TStringList.Create;  
 Texto.Add('1');  
 Texto.Add('2');  
 Texto.Add('3');  
 ShowMessage(Texto.Strings[Texto.Count-1]);  
 FreeAndNil(Texto);
end;
// contadar:
total := Texto.Count;
</pre>

<p>outro exemplo:</p>
<pre>
var
  animals : TStringList;            // Define our string list variable
  i       : Integer;
begin
  // Define a string list object, and point our variable at it
  animals := TStringList.Create;

  // Now add some names to our list
  animals.Add('Cat');
  animals.Add('Mouse');
  animals.Add('Giraffe');

  // Now display these animals
  for i := 0 to animals.Count-1 do
    ShowMessage(animals[i]);  // animals[i] equates to animals.Strings[i]

  // Free up the list object
  animals.Free;
end;  
</pre>

<h1>Memo</h1>

<p> Número de linahs de um memo</p>
<p><em>Memo.Lines.Count;</em></p>
<p>Para ler linha por linha:</p>
<pre>
for i := 0 to Memo.Lines.Count -1 do
begin
  Linha := Memo.Lines[i];
  { Faz o que quiser com a linha }
end;
</pre>

<h1>Classes</h1>
uses 'Classes'<br>
Declarar a instância da classe<br>
{ Private declarations }<br>
MinhaLista: TStringList;<br>
Executar o método construtor para instanciar a classe<br>
MinhaLista := TStringList.Create();<br>
Depois de instanciada, os métodos e propriedades da classe ficam disponíveis<br>
MinhaLista.Add(Edit1.Text);<br>
Ver o conteúdo...<br>
Label1.Caption := MinhaLista.GetText ;<br>
ou...<br>
var<br>
i : integer;<br>
begin<br>
for i := 0 to MinhaLista.Count-1 do<br>
ListBox1.Items.Add (MinhaLista.Strings[i]);<br>
end;<br>
Último passo: Destruir a instância com o método destrutor<br>
MinhaLista.Destroy;<br>
<hr />

Trabalhando com Case... of<br>
Criando seleções<br>
var Seletor : char;<br>
begin<br>
Seletor := 'C';<br>
Case Seletor of<br>
'A' : ShowMessage('Escolhido A');<br>
'B' : ShowMessage('Escolhido B');<br>
'C' : Begin<br>
Showmessage('Escolhido C');<br>
Halt; // encerra o programa<br>
end;<br>
else// caso não seja uma destas letras<br>
ShowMessage('Não escolhido um destes ítems');<br>
end;<br>
Trabalhando com Case II<br>
Case RadioGroup1.ItemIndex of<br>
0 : Form2.BorderStyle := bsDialog;<br>
1 : Form2.BorderStyle := dbNone;<br>
end;<br>
<br>
Usando o Repeat<br>
var<br>
N : String;<br>
begin<br>
Repeat;<br>
N := Inputbox('GetNumber', 'Insira um número','');<br>
Until N:= '7';<br>
end;<br>
Atribuir Mesmo Valor para Vários Edits em um Form<br>
for i := 0 to ComponentCount - 1 do<br>
if Components[i] is TEdit then<br>
TEdit(Components[i]).Text := Valor;<br>
<br>
Testa se há disco no Drive A:<br>
function TForm1.TemDiscoNoDrive(const drive : char): boolean;<br>
var<br>
DriveNumero : byte;<br>
EMode : word;<br>
begin<br>
result := false;<br>
DriveNumero := ord(Drive);<br>
if DriveNumero >= ord('a') then<br>
dec(DriveNumero,$20);<br>
EMode := SetErrorMode(SEM_FAILCRITICALERRORS);<br>
try<br>
if DiskSize(DriveNumero-$40) <> -1 then<br>
Result := true else messagebeep(0);<br>
finally<br>
SetErrorMode(EMode);<br>
end;<br>
end;<br>
<br>
procedure TForm1.Button1Click(Sender: TObject);<br>
begin<br>
if TemDiscoNoDrive('a') then<br>
ShowMessage('Tem disco no drive A:')<br>
else ShowMessage('Não tem disco no drive A:');<br>
end;<br>
<br><br>
Close em um Form<br>
OnCloseQuery //No evento OnCloseQuery. A segunda opção ("Não") recebe o foco.<br>
CanClose := Application.MessageBox( 'Confirme Operação','Terminar Aplicação ?',<br>
MB_ICONQUESTION + MB_YESNO + MB_DEFBUTTON2 ) = ID_YES;<br>
<br>
Salvar dados antes de fechar:<br>
//no evento OnClose:<br>
if Table1.Modified then<br>
if Application.MessageBox('Gravar alterações?','Dados Alterado',MB_ICONQUESTION + MB_YESNO) = IDYES then<br>
Table1.Post<br>
else<br>
Table1.Cancel<br>
<br>
Obtendo o número serial do HD<br>
Function SerialNum(FDrive:String) :String;<br>
Var<br>
Serial:DWord;<br>
DirLen,Flags: DWord;<br>
DLabel : Array[0..11] of Char;<br>
begin<br>
Try<br>
GetVolumeInformation(PChar(FDrive+':\'),dLabel,12,@Serial,DirLen,Flags,nil,0);<br>
Result := IntToHex(Serial,8);<br>
Except<br>
Result :='';<br>
end;<br>
end;<br>

Criando Tabelas<br>
Através da função FieldDefs.ADD. Parâmetros: nome do campo, tipo, Tamanho, Chave_Primária.<br>
Procedure Cria_Tabela(Alias,Nome_Tabela:String);<br>
Begin<br>
With TTable.Create(Application) do<br>
begin<br>
Active := False;<br>
DatabaseName :=Alias;<br>
TableName := Nome_Tabela;<br>
TableType := ttDefault;<br>
FieldDefs.Add('CODCLI', ftString, 5, False);<br>
FieldDefs.Add('NOMCLI', ftString, 40, False);<br>
FieldDefs.Add('DATCAD', ftDate, 0, False);<br>
CreateTable;<br>
Free;<br>
end;
end;

Como Usar:<br>
procedure TForm1.Button1Click(Sender: TObject);<br>
begin<br>
Cria_Tabela('C:\Temp','Alunos.db');<br>
end;<br>

LOCALIZAR<br>
//nesta caixa de diálogo, o campo nome tem que ser o primeiro<br>
var // uma variárvel tem que ser criada.<br>
nome : string;<br>
Nome : = inputbox( ' Localizar ' , ' digite o nome ' , ' ' ) ;<br>
if nome <> ' ' then<br>
begin<br>
if not table1.findkey ( [ nome ] ) then<br>
showmessage ( ' nome não encontrado ' ) ;<br>
end;<br>
Simplificando: Table1.findkey([edit1.text])<br>
<br>
ou<br>
table1.setkey;<br>
table1.fields[0].AsString := Edit1.text;<br>
Table1.GotoKey;<br>
<br>
Apenas a linha abaixo :<br>
Table1.FindKey([Edit1.Text]);<br>
Apenas a linha abaixo :<br>
Table1.FindNearest([Edit1.Text]);<br>
Table1.SetKey; // Primeiro campo é a chave<br>
Table1.FieldName('Cidade') := Edit1.Text;<br>
Table1.GotoKey;<br>
<br>
Table1.IndexName := 'NomeCliente'; // procurar em um índice secundário<br>
Table1.Open;<br>
Table1.SetKey;<br>
table1NomeCliente.AsString := Edit1.Text;<br>
Table1.GotoNearest;<br>
.<br>
// Procurar em um índice primário ou secundário<br>
Table1.IndexName := 'Nome'<br>
Table1.Open;<br>
Table1.SetKey;<br>
Table1Nome_Cliente.AsString := Edit1.Text;<br>
Table1.GotoNearest;<br>
<br>
Locate// procura em um índice primário ou secundário<br>
Table1.Locate('Nome',Trim(Edit1.text),[LoPartialKey,loCaseInsensitive]);<br>
if not DM.Table1.Locate('Vendedor;Data',VarArrayOf([EditVendedor.text, EditData.text]),[loCaseInsensitive]) then<br>
ShowMessage('O vendedor não realizou venda nesa data');<br>
<br>
FindKey<br>
//Procura um nome em um campo. ( no primeiro campo ).<br>
// No evento OnClick do Botão Ok, digite<br>
begin<br>
if not DataModule.tsenha.FindKey ( [ editNome.text ] ) then<br>
beguin<br>
ShowMessage ( ' senha desconhecida ' );<br>
Exit;<br>
end ;<br>
<br>
&EXCEPTIONS - Exceções<br>
Access violation<br>
Decrare a constante:<br>
const<br>
ChaveViolada = 9729;
No evento OnPostError da tabela, digite:<br>
if (E is EDBEngineError) then<br>
if (E as EDBEngineError).Error[0].Errorcode = ChaveViolada then<br>
begin<br>
Table1.Cancel;<br>
ShowMessage('este código já existe');<br>
end;<br>
abort<br>
<br>
Outras exceções<br>
if(E is EDBEngineError) then<br>
with EDBEngineError(E) do<br>
case Errors[0].ErrorCode of<br>
DBIERR_KEYVIOL: ShowMessage('Cliente já cadastrado.');<br>
DBIERR_REQDERR: ShowMessage('Campo obrigatório não preenchido.');<br>
end<br>
else<br>
ShowMessage('Erro no banco de dados:' + #13#13 + E.Message);<br>
Action := daAbort;<br>
<br>
<b>construindo gráfico</b><br>
With Series1 do<br>
Begin<br>
  Add( 40, 'Pencil' , clRed ) ;<br>
  Add( 60, 'Paper', clBlue ) ;<br>
  Add( 30, 'Ribbon', clGreen ) ;<br>
end;<br>
<br>
Tirando Senha tabela paradox:<br>
Para PARADOX 7.0 -> "jIGGAe" ou "cupcdvum"<br>
Para PARADOX 5.0 -> "jIGGAe" ou "cupcdvum"<br>
Para PARADOX 4.0 (DOS) -> "nx66ppx"<br>
<br>
<hr>



Query - Parametros<br>
// digitar no SQL do query<br>
{ Select * from geral where Nome like :ord<br>
Na properties Params colocar : Name := Ord, Value := %}<br>
<br>
//comando usado na ultima pesquisa<br>
SELECT Cx_Dia, Cx_CMovi, Cx_vlrSaida,  SUM(Cx_VlrSaida) AS TotDia<br>
FROM Caixa.DB<br>
WHERE Cx_vlrSaida > 0<br>
AND Cx_CMovi = 'PRP'<br>
GROUP BY Cx_Dia, Cx_CMovi, Cx_vlrSaida<br>
ORDER BY Cx_Dia<br>
+++++++++++<br>

<h1>ListBox </h1>
<p><i>//Faz um ListBox exibir o conteúdo de uma tabela</i><br />
var<br />
i: Integer;<br />
begin<br />
ListBox1.Clear;<br />
for i := 0 to Table1.FieldCount - 1 do<br />
ListBox2.Items.Add(Table1.Fields[i].AsString);<br />
end;<br />
<br />
<p><i>Pegar o conteúdo</i><br />
ShowMessage(ListBox1.Items[ListBox1.ItemIndex]);</p>
<hr />

<h1>CheckListBox</h1>
<p>lbSelecionados.Clear; //Limpa a lista de items do clSelecionados<br />
for i := 0 to clbItems.Items.Count - 1 do <br />
if clbItems.Checked[i] then //Se o item corrente estiver selecionado<br />
lbSelecionados.Items.Add(TTexto(clbItems.Items.Objects[i]).Valor);<br />
<br />

<p>%BOOKMARKS</p>
//guardar uma posição no registro<br>
var<br>
BM :tBookMark;<br>
{...}<br>
// Grava um Registro<br>
if bm = nil then // se bm está vazio então...<br>
bm := table1.GetBookMark; // marque um<br>
ou<br>
if BookMark = nil then<br>
BookMark := Table1.GetBookMark;<br>
{++}<br>
<br>
// ir para o registro guardado<br>
if BookMark <> nil then // se o BookMark não está vazio...<br>
begin<br>
table1.GotoBookMark(BookMark) // vá para o marcado<br>
end;<br>
ou..<br>
if BM <> nil then<br>
begin<br>
BM := table1.GetBookMark(BM);<br>
<br>
{++}<br>
//limpa da memória o registro guardado<br>
if BookMark <> nil then // se o BookMark não está vazio então faça..<br>
begin<br>
Table1.FreeBookMark (BookMark); // libere o marcado..<br>
BookMark := nil; // deixe-o vazio<br>
end;<br>
ou<br>
if bm <> nil then<br>
begin<br>
Table1.FreeBookMark (bm);<br>
bm := nil;<br>
end;<br>
// conjunto de comandos<br>
if BookMark < > nil then<br>
begin<br>
table1.GotoBookMark(BookMark);<br>
Table1.FreeBookmark(BookMark);<br>
BookMark := nil;<br>
end;<br>
<hr />

<h1>Stringgrid</h1>
<p>sgridc.Visible := false;</p>
<p><i>colocando o titulo</i></p>
<p>
  sgridc.Visible := false;<br />
  SGridC.Cells[0,0] := 'Exeme';<br />
  SGridC.Cells[1,0] := 'Data';<br />
  SGridC.Cells[2,0] := 'I.D.';<br />
  SGridC.RowCount := 1;<br />
  sgridc.Visible := true;<br />
</p>  

<p><i>Inserindo em um loop</i></p>
<p>SGridC.RowCount :=  SGridC.RowCount + 1;<br />
SGridC.Cells[0,vk] :=  ComplementoNome[vcodigo];<br />
      SGridC.Cells[1,vk] :=  qyc.FieldByName('dia').AsString;<br />
      SGridC.Cells[2,vk] :=  qyc.FieldByName('complemento_id').AsString;<br />
</p>

<p>Cor no string grid<br />
<i>No evento ONDrawCel, digite:</i></p>
<p>  if gdFocused in State then<br />
  with (Sender as TStringGrid).Canvas do<br />
    begin<br />
      Brush.Color := clLime;<br />
      FillRect(Rect);<br />
      TextOut(Rect.Left, Rect.Top, sgridC.Cells[acol,arow]);<br />
    end;<br />
</p>
<p>Pegando a linha que foi selecionada</p>
<p>OnSelectCell <i> = esta é o evento</i></p>
<p>linhax := Arow; <i>// pego a linha que está selecionada</i></p>

<p></p>
<p>Pegar o código da linha</p>
<pre>
var
  k : Integer;
begin
  try  k := StrtoInt(SGridC.Cells[0, linhax]);// pego o id
  except k := 0;
  end;
  if (k = 0) then
    begin
      erro('Campo não escolhido','Escolha um exame complementar');
      exit;
    end;
</pre>

<p>colocando uma imagem</p>
<pre>
var
  Bitmap: TBitmap;
begin
  Bitmap:=TBitmap.Create;
  Bitmap.LoadFromFile('c:\f.bmp');
  sgx.Canvas.StretchDraw(sgx.CellRect(1,1),Bitmap);
  Bitmap.Free;
</pre>

<p>Colocar o texto à direita ou centralizado</p>
<pre>
procedure TForm1.StringGrid1DrawCell(Sender: 
TObject; ACol, 
ARow: Integer; Rect: TRect; State: TGridDrawState); 
var 
  strTemp: string; 
  Format: integer; 
begin 
 strTemp := StringGrid1.Cells[ACol,ARow]; 
 StringGrid1.Canvas.FillRect(Rect); 
 
 if (ACol = 0) then // se coluna = 0 alinha ao centro 
   Format := DT_CENTER 
 else if (ARow = 0) then se linha=0 alinha ao centro 
   Format := DT_CENTER 
  else // caso contrario a esquerda 
  Format := DT_LEFT; //DT_RIGHT alinha a direita 
 if (ARow = 0) then 
     StringGrid1.Canvas.Font.Style := [fsBold]; 
 
 DrawText(StringGrid1.Canvas.Handle,PChar(strTemp),-1,Rect,Format); 
end;
</pre>

<hr />


<b>DBGrid</b><br>
Maiúsculo ou Minúsculo no DBGrid<br>
<i>//OnKeyPress do DBGrid:</i><br>
Key := AnsiUpperCase(Key)[1];<i>//ou</i><br>
Key := AnsiLowerCase(Key)[1];<br>
<br>
Cores do DBGRid<br>
Coloque a propriedade defaultdrawdata do dbgrid em FALSE<br>
No evento onDrawColumnCell coloque<br>
If QyTalPrazo.Value > DATE then<i> // condição </i><br>
begin<br>
Dbgrid1.Canvas.Font.Color:= clFuchsia; <i>// coloque aqui a cor desejada</i><br>
DBGrid1.Canvas.Brush.Color:= clAqua;<br>
DBGrid1.Canvas.FillRect(Rect);<br>
DBGrid1.DefaultDrawColumnCell(Rect, DataCol, Column, State);<br>
end;<br>
<br>
++++++++

Soma<br>
// RecordCount, conta quantos registros ha na Tabela<br>
Label1.Caption := InttoStr(Table1.Recordcount);<br>
<br>
Os estados de um Data Base<br>
if Table1.State = dsEdit then<br>
begin...<br>
Para saber o Estado de um DataBase. Digite no Evento OnStateChange do DataSourse:<br>
Var<br>
S : String; begin<br>
Case Table1.State of<br>
dsInactive : S := 'Inativo';<br>
dsBrownse : S := 'Browse';<br>
dsEdit : S := 'Edição';<br>
dsInsert : S := 'Inserção';<br>
dsSetKey : S := 'SetKey';<br>
dsCalcFields : S := 'CalkFields';<br>
end;<br>
Label1.Caption := S;<br>
<br>
<b>Para digitar só números em um edit</b><br>
if not (Key in['0'..'9',Chr(8)]) then Key:= #0;<i> //evento OnKeyPress</i><br>
<i>// Obs: Chr(8), para BackSpace e DecimalSeparator, para a vírgula dentro dos colchetes.</i></br>
<br>
Alias<br>
<br>
{Criando um alias I}<br>
Check(DBiAddAlias(Nil, Pchar('AliasName'),Nil, Pchar('AliasPath), true));<br>
AliasName = nome do alias;<br>
AliasPath = caminho do alias;<br>
Inclua em Uses = BDE e BD;<br>
<br>
{Criando Alias II}<br>
vPathName := ExtractFilePath (ParamStr (0));<br>
{ se o alias não existir... }<br>
if not Session1.IsAlias('Infocad') then<br>
begin<br>
{ Adiciona o alias }<br>
Session1.AddStandardAlias('Infocad', vPathName, 'PARADOX');<br>
{Salva o arquivo de configuração do BDE }<br>
Session1.SaveConfigFile;<br>
end;<br>
<br>
{Criando um alias III}<br>
// Utilizando o componente TSession<br>
session1.ConfigMode:=cmSession;<br>
Session1.AddStandardAlias('NomedoAlias','C:\Arquivos de Programas\Arquivos comuns\Borland Shared\Data','PARADOX');
<br>
Atualizando as informações em ambiente de rede<br>
Acessando a mesma tabela concorrente com outra estação ou outro objeto Query, Table<br>
a) Crie procedure para uso no evento OnActive:<br>
Procedue TTorm1.FormRefresh(Sender: TObject);<br>
begin<br>
Table1.Refresh;<br>
...<br>
TableN.Refresh;<br>
end;<br>
b)No evento OnActive do formulário acrescente a linha:<br>
Application.OnActive := FormRefresh;<br>
c) No evento OnShow do formulário acreste a linha<br>
FormRefresh(Sender);<br>
d) No evento OnAfterPost de cada objeto TTable acrescente as linhas;<br>
Table.FlushBuffer;<br>
FormRefres(Self);<br>
<br>
&Salvando Dados Fisicamente em uma Tabela<br>
USES DBIProcs;<br>
Nos eventos OnAfterPost e OnAfterDelete, digite:<br>
DBISaveChanges(Table1.handle);<br>
Salvando Os dados Visicamente II<br>
USES BDE:<br>
DbiSaveChandges((Dataset as TTable).Handle);<br>
<br>
&DBNavigator<br>
//Para pegar o nome do botão que foi pressionado<br>
DBNavigator1.BtnClick(nbNext);<br>
// pegando o botão clicado<br>
if Button in [nbFirst,nbLast,nbPrior,nbNext] then<br>
DBNavigator.DataSource.DataSet.Refresh;<br>
<br>
<hr />

<p><b>Word e Excel</b></p>
<i>//Em Uses:</i><br />
ComObj<br />
Variants <i>(para trabalhar com variantes)</i><br />
<br />
<p><b>EXCEL</b></p>
<i>codigo de cores</i><br>
<i>// 6- amarelo 5- azul 16- cinza escuro 17- azul claro 3- vermelho 7- rosa 8- azulclaro 9- marrom</i><br>
<i>//declare isto na private da Unit</i><br>
FExcel : Variant;<br>
<i>//CONTEÚDO DO BOTÃO</i><br />
var<br>
vColR : Variant; <i>//colres e estilos</i><br>
vCelR : Variant; <i>//formulas e cores internas</i><br>
li : integer; <i>//para a tabela</i><br>
begin<br>
If not(Application.MessageBox('Exportar dados para o Excel?','ATENÇÃO',MB_ICONEXCLAMATION + MB_YESNO) = IDYES) Then<br>
exit;<br>
FExcel := CreateOleObject('Excel.Application');<br>
FExcel.Visible := False;<br>
FExcel.Workbooks.Add(-4167);//tem q ter<br>
//conteúdo - linha coluna<br>
li := 1;<br />
FExcel.WorkBooks[1].Sheets[1].Cells[li,1]:='Nome da Escola';<br />
Inc(li);<br />
FExcel.WorkBooks[1].Sheets[1].Cells[li,1]:='Titulo do Relatório';<br>
Inc(li);<br>
FExcel.WorkBooks[1].Sheets[1].Cells[li,1]:='Coluna Um';<br>
FExcel.WorkBooks[1].Sheets[1].Cells[li,2]:='Coluna Dois';<br>
FExcel.WorkBooks[1].Sheets[1].Cells[li,3]:='Coluna tres';<br>
//nome da pasta<br>
FExcel.Workbooks[1].WorkSheets[1].Name := 'Nota10';<br>
<br>
//selcione celula<br>
//vCelR := FExcel.Workbooks[1].WorkSheets['Nota10'].Range['C1:F25'];//+de 1 celula<br>
vCelR := FExcel.Workbooks[1].WorkSheets['Nota10'].Range['D4'];<br>
vCelR.Formula := '=A4+B4';//coloco uma formula<br>
//vCelR.Formula := '=RAND()';//outro exemplo<br>
vCelR.Columns.Interior.ColorIndex := 6;//coloco a cor de fundo<br>
vCelR.Borders.LineStyle := 1; //escolho a borada<br>
<br>
//trabalhando com a página indicada<br />
vColR := FExcel.Workbooks[1].WorkSheets['Nota10'].Columns;<br />
vColR.Columns[1].ColumnWidth := 5;//tamanho da colulas<br />
vColR.Columns[2].ColumnWidth := 50;<br />
//cores e estilos<br />
vColR.Columns.Item[1].Font.Bold := True;<br />
vColR.Columns[1].Font.Color := clBlue;<br />
FExcel.Columns.AutoFit; <em>// faz com que as colunas se expandam conform o tamanho</em><br />
ShowMessage('Concluído');<br>

FExcel.Visible := True;<br>
<br>
<i>//coloque isto no OnDestroy do form</i><br />
if not VarIsEmpty(FExcel) then<br />
FExcel.Quit;<br>
<br>
<b>WORD</b><br>
//declare isto na private da Unit<br>
vW : Variant;<br>
<br>
//begin do botão<br>
If not(Application.MessageBox('Exportar para o Word?','ATENÇÃO',MB_ICONEXCLAMATION + MB_YESNO) = IDYES) Then
exit;<br>
<br>
vW:= CreateOleObject('Word.Application');<br>
vW.Visible := false;<br>
vW.Documents.Add;<br>
vW.Selection.TypeText(Text := 'Documento do Word com Tabelas');<br>
vW.Selection.TypeText(Text := #13);//prox. linha<br>
vW.Selection.TypeText(Text := 'aldo' + #9 + 'pai' + #9 + 'gravatá');<br>
//Adiciona tabela de 2 linhas e 3 colunas<br>
vW.ActiveDocument.Tables.Add(<br>
Range := vW.Selection.Range,<br>
NumRows := 2,<br>
NumColumns := 2);<br>
//Escreve na primeira célula }<br>
vW.Selection.TypeText(Text := 'Linha 1, Coluna 1');<br>
vW.Selection.MoveRight(12);//Próxima célula<br>
vW.Selection.TypeText(Text := 'Linha 1, Coluna 2');<br>
vW.Selection.MoveRight(12);<br>
vW.Selection.TypeText(Text := 'Linha 2, Coluna 1');<br>
vW.Selection.MoveRight(12);<br>
vW.Selection.TypeText(Text := 'Linha 2, Coluna 2');<br>
vW.Selection.MoveRight(12);<i>// inclui uma linha abaixo q fica fazia</i><br>
vW.Selection.MoveDown; <i>//fez o fim da tabela</i><br>
vW.Selection.TypeText(Text := 'texto fora' + #13);<br>
<i>//</i><br>
vW.Selection.Font.Bold := true;<br>
vW.Selection.TypeText(Text := 'negrito' + #13);<br>
vW.Selection.Font.Bold := false;<br>
vW.Selection.Font.Italic := true;<br>
vW.Selection.TypeText(Text := 'itálico' + #13);<br>
vW.Selection.Font.Italic := false;<br>
vW.Selection.Font.Size := 20;<br>
vW.Selection.TypeText(Text := 'texto grande' + #13);<br>
vW.Selection.Font.Size := 10;<br>
vW.Selection.TypeText(Text := 'texto pequeno' + #13);<br>
vW.Selection.Font.color := clYellow;<br>
vW.Selection.name:= 'Arial';<br>
<i>//alinhametnos = 0, 1, 2, 3</i><br>
vW.Selection.ParagraphFormat.Alignment := 1;<br>
vW.Selection.TypeText(Text := 'aldo - alinhamento de texto - aldo' + #13);<br>
<i>//alinhametnos = 0, 1, 2, 3</i><br>
vW.Visible := true;<br>
<br>
//coloque isto no OnDestroy do form<br>
if not VarIsEmpty(vW) then<br>
vW.Quit;<br>
<br>
<hr />

<p>Imagem no Form</p>
Colocar uma figura bmp, no form sem o Picture<br>
var<br>
BitMap : TBitMap;<br>
Begin<br>
BitMap : = TBitMap.Creat ;<br>
With BitMap do<br>
Biguin<br>
LoadFromFile( ' c : \ figura . bmp' ) ;<br>
Transparent := true ;<br>
Form1. Canvas . Draw (50,50, bitMap);<br>
end:<br>
end;<br>
//Desktop, imagem no form<br>
//Procedure TForm E. FormResize(Sender: tobject);<br>
Var<br>
R : TRect ;<br>
DC : HDc ;<br>
Canv : TCanvas ;<br>
Begin<br>
R : = Rect (0,0, Screen.Width, Screen.Height);<br>
DC : = GetWindowDC (GetDeskTopWindow);<br>
Canv := TCanvas.Create;<br>
Canv . Handle := DC;<br>
Canvas . CopyRect(R,Canv,R);<br>
ReleaseDC (GetDeskTopWindow, DC);<br>
end;<br>
<br>
CopyFile, para copiar arquivos<br>
CopyFile(pchar('c:\conto.txt'),('a:\conto.txt'),false);<br>
// no final: true=não regrava o arquivo, se false, ele regrava.<br>
<br>
A Tecla Pressionada<br>
//No evento OnKeyDown, digite:<br>
Label1.Caption := Format('O código da tecla é: %d', [Key]);<br>
<br>
O componente TMediaPlayer<br>
Para ouvir um som<br>
With MediaPlayer1 do<br>
begin<br>
FileName := 'c:\bettoven.wav'; // pode ser um Mid<br>
Open;<br>
Play;<br>
end;
<br>
Para ver um *.avi no form...<br>
with MediaPlayer1 do
begin<br>
FileName := 'c:\super.avi';<br>
Open;<br>
Display := Form2;<br>
Form2.Show;<br>
Play;<br>
end;<br>
<br>

<h1><a name="arqtexto"></a> Arquivos Texto</h1>

<p><em>Carregando o texto em um RichEdit</em><br />
RichEdit1.Lines.LoadFromFile('c:\aviso.txt');</p>

//colocando cores<br>
ReachEdit1.Font.Color := clGreen;<br>
Estilos de Texto<br>
//testo em negrito<br>
if CheckNegrito.Checked then //Para o botão Negrito<br>
Memo1.Font.Style := Memo1.Font.Style + [fsBold] // coloca em estilo negrito<br>
else<br>
Memo1.Font.Style := Memo1.Font.Style - [fsBold]; // retira o estilo negrito<br>
//Memo1.Font.Style := Memo1.Font.Style + [fsItalic] // Para o botão Itálicov
//Memo1.Font.Style := Memo1.Font.Style + [fsUnderline] // Para o botão Sublinhado<br>

<h2> texto em negrito II </h2>
<p>if BoldButton.Down then <br />
CurrText.Style := CurrText.Style + [fsBold]<br>
else<br>
CurrText.Style := CurrText.Style - [fsBold];<br>
end;<br>
function TMainForm.CurrText: TTextAttributes;<br>
begin
if Editor.SelLength > 0 then Result := Editor.SelAttributes<br>
else Result := Editor.DefAttributes;<br>
end;<br>
<br>
Alinhamento do texto<br>
{taLeftJustify, taCenter, taRightJustify}
Label1.Alignment := taLeftJustify;<br>

<h1>Trabalhando com Arquivos .INI</h1>
<p><i>//Acresentar em Uses: IniFiles</i><br />
ArqIni: TIniFile;<br />
<i>//no evento OnCreate, do form, digite:</i><br />
ArqIni := TIniFile.Create('c:\windows\ArqIni.ini');<br>
lendo um arquivo ini<br>
EditString.Text := ArqIni.ReadString('String', 'texto', '');<i>// lendo um valor string</i><br>
EditString.Top := ArqIni.ReadInteger('Integer', 'altura', 0);<i> //lendo um valor inteiro</i><br>
EditString.Visible := ArqIni.ReadBool('Boolean', 'visivel',False);<i>//lendo um valor boolean</i><br>
<i>//lendo um arquivo ini em um meno:</i><br />
Memo1.Lines.LoadFromFile('c:\inicial.ini');<br />

<p><strong>gravando em um arquivo .ini</strong></p>
ArqIni.WriteString('String', 'texto', EditString.Text);<i>//gravando um valor string</i><br>
ArqIni.WriteInteger('Integer', 'altura', SpinEdit1.value);<i>//gravando um valor inteiro</i><br>
ArqIni.WriteBool('Boolean', 'visivel', CheckBox1.Checked);<i>// gravando um valor boolean</i><br>
<br>
<i>//no evento OnDestroy, do form, libere o nosso arquivo</i><br>
ArqIni.Free;<br>


<h2>///Rotina para ler de um arquivo texto:</h2>
<pre>
var
  f: TextFile;
  linha: string;
begin
  AssignFile(f,'c:\arquivo_qualquer.txt');
  Reset(f); //abre o arquivo para leitura;
  while not eof(f) do
  begin
    Readln(f,linha); //le do arquivo e desce uma linha. O conteúdo lido é transferido para a variável linha
    Memo1.lines.add(linha);
  end;
  Closefile(f);
end;
</pre>

<h2> para escrever no arquivo texto  </h2>

<p>var <br>

vArqRel : TextFile;<i>// Declarei a variaável</i><br >
f : String; <br>
begin <br>
f := ExtractFilePath(ParamStr (0)) + 'User.txt'; <i>// no local do executável</i><br />
<pre>
try
  AssignFile(vArqRel, f);
  Rewrite(vArqRel); // esta linha OU a de baixo = este apaga o texto existe para algo novo
  Append(vArqRel); // abre para gravação no fim do texto existente
  WriteLn(vArqRel, 'aldosena10@gmail.com');
finally
    CloseFile(vArqRel);
end;
</pre>  
end; </p>

<pre>
var
  f : TextFile;
begin
  AssignFile(f,'c:\arquivo_qualquer.txt');
  Rewrite(f); //abre o arquivo para escrita
  Writeln(f,'Testando'); // escreve no arquivo e desce uma linha
  Write(f,'Clube Delphi'); //escreve no arquivo sem descer a linha
  Closefile(f); //fecha o handle de arquivo
end;
</pre>

<p>AssignFile(arq, nomeArq); - 
<i>Associa um nome lógico de arquivo (arq) ao arquivo físico (nomeArq). "nomeArq" é uma cadeia de caracteres que representa qualquer nome de arquivo a ser manipulado. 
Este nome é atribuído à variável "arq" e todas as operações sobre "arq" serão realizadas no arquivo em disco de nome "nomeArq"..</i><br />

<p> Rewrite(arq); - 
<i>Um novo arquivo em disco com o nome atribuído à variável é criado e preparado para processamento, um ponteiro é colocado no início do arquivo criado.<br />
Caso o arquivo a ser criado já exista, esta instrução apaga o arquivo para criá-lo novamente.<br>
Um novo arquivo em disco com o nome atribuído à variável "arq" é criado e preparado para processamento, um ponteiro de arquivo é colocado no início do arquivo criado. Caso o arquivo a ser criado já exista, esta instrução apaga o arquivo para criá-lo novamente. </i></p>

<p> Reset(arq); - 
<i>Prepara um arquivo <b>existente</b>  para leitura e coloca o ponteiro de arquivo no início. <br>
Caso o arquivo não exista, esta instrução provocará um erro de Entrada/Saída (Input/Output).<br>
Prepara um arquivo existente para leitura e coloca o ponteiro de arquivo no início. Caso o arquivo não exista, esta instrução provocará um erro de Entrada/Saída (Input/Output).</i><br />

<p>Append(arq); - 
<i> Abre um arquivo texto existente para estendê-lo (saídas adicionais). Caso o arquivo não exista, esta instrução provocará um erro de Entrada/Saída (Input/Output).</i></p>

<p>CloseFile(arq); - 
<i>Fecha o arquivo texto aberto.</i><br />
Readln(arq, linha); - 
<i>Lê uma linha no arquivo indicado por "arq".</i><br />
Read(arq, ch); - 
<i>Lê um caractere no arquivo indicado por "arq".</i><br />
Writeln(arq, lista_de_expressões); - 
<i>Grava no arquivo texto "arq" um ou mais valores colocando a marca de fim-de-linha no final da lista.</i><br />
Write(arq, lista_de_expressões); - 
<i>Grava no arquivo texto "arq" um ou mais valores em sequência.</i><br />
Eoln(arq); - 
<i>Função lógica que retorna True se é final de linha, ou seja, se o ponteiro do arquivo indica a leitura da marca de fim-de-linha (CR/LF). Caso contrário, a função retorna False.</i><br />
Eof(arq); - 
<i>Função lógica que retorna True caso o ponteiro do arquivo indique a leitura da marca de fim-de-arquivo, caso contrário, a função retorna False.  </i></p>  
  
<p>Movimento</p>
fazer um panel ter seu texto em movimento<br>
var<br>
texto : string;<br>
begin<br>
texto : = panel1.caption;<br>
panel1.caption := copy(texto,2,length (texto)) + texto[1];<br>
end;<br>


<p>ColorGrid</p>
Form1.Color := ColorGrid1.ForegroundColor ; //botão esquerdo do mouse<br>
Form1.Color := ColorGrid1.BackgroundColor ;// botão direito do mouse<br>
<br>

<h1>Arquivos</h1>
<h2>Exluir um arquivo</h2>
      try		<br />
        if DeleteFile(a) then		<br />
          mm1.Lines.Add('Arquivo antigo DELETADO...');		<br />
      except		<br />
          mm1.Lines.Add('Erro ao tentar exlcluir arquivo antigo...');		<br />
      end;		<br />
</p>
	  
<h2>Movimento arquivo</h2>	  
var<br>
origem, destino : string;<br>
begin<br>
origem := 'c:\delete\faq.txt';<br>
destino:= 'c:\games\faq.txt';<br>
if not copyfile(pchar(origem),pchar(destino),true) then<br>
showMessage ( 'problemas com' + origem + 'para' + destino)<br>
<br>
MOVENDO UM OBJETO<br>
// Coleque em um objeto ( ex: um Button)<br>
// Na guia VAR, digite<br>
MouseDownSpot : TPoint;<br>
Capturing : bool;<br>
// No evento OnMouseDown<br>
SetCapture(Button1.Handle);<br>
Capturing := true;<br>
MouseDownSpot.X := x;<br>
MouseDownSpot.Y := Y;<br>
// No evento OnMouseMove<br>
if Capturing then<br>
begin<br>
Button1.Left:= Button1.Left-(MouseDownSpot.x -x);<br>
Button1.Top:= Button1.Top - (MouseDownSpot.y -y);<br>
end;<br>
// No evento OnMouseUp<br>
if Capturing then<br>
begin<br>
ReleaseCapture;<br>
Capturing := false;<br>
Button1.Left := Button1.Left - (MouseDownSpot.x -x);<br>
Button1.Top := Button1.Top - (MouseDownSpot.y - y);<br>
end;<br>
<br>
Arquivos Help<br>
// digite a linha abaixo para chamar um arquivo help<br>
WinHelp(Form1.handle, 'c:\Ajuda.hlp', HELP_CONTENTES,0);<br>
<br>
&Randomize<br>
//A linha de comando abaixo faz o label exibir aleatóriamente um número de 1 a 100<br>
Label1.Caption := InttoStr(Random(100));<br>
<br>
&Hint<br>
//colocar no evento OnCreate do form principal..<br>
Application.HintColor := clYellow; // define a cor de todos os hints<br>
Application.HintPause := 200; // define o tempo de espera de um hint<br>
Edit1.hint := 'Primeira linha' + #13 + 'segunda linha';//Hint com quebra de linha<br>
<br>
&Criar um componente em tempo de execução<br>
var<br>
PictImg1 : TImage;//declarando um TImage<br>
begin<br>
PictImg1 := tImage.Create(self);<br>
PictImg1.Height := 200;<br>
pictImg1.Width := 200;<br>
PictImg1.Picture.LoadFromFile('C:\1.bmp');<br>
PictImg1.parent := Self;<br>
end;<br>
<br>
Cores com RGB<br>
//o form abaixo recebe a cor composta por:" red, green e blue"<br>
Form1.Color := Rgb(100, 100, 100);<br>
<br>
&Progess Bar<br>
Criando um ProgressBar em tempo de execução<br>
//Declare a procedure abaixo<br>
procedure TestProgress(Form: TForm; Count: SmallInt);<br>
var<br>
ProgressBar1: TProgressBar;<br>
i: SmallInt;<br>
begin
ProgressBar1 := TProgressBar.Create(Form);<br>
try<br>
ProgressBar1.Parent := Form;<br>
ProgressBar1.Align := alBottom;<br>
ProgressBar1.Min := 0;<br>
ProgressBar1.Max := Count;<br>
ProgressBar1.Step := 1;<br>
for i := 1 to Count do<br>
ProgressBar1.Stepit;<br>
ShowMessage('Now the ProgressBar control will be freed');<br>
finally<br>
ProgressBar1.Free;<br>
end;<br>
end;<br>
Finalmente, facha a chamada para o ProgessBar...<br>
TestProgress(Self, 1000);<br>
form2.show;<br>
<br>
O Componente TCalendar<br>
Calendar1.PrevYear;//para exibir o ano anterior<br>
Calendar1.NextYear;//para exibir o proximo ano<br>
Calendar1.PrevMonth;//para exibir o mês anterior<br>
Calendar1.NextMonth;//para exibir o próximo mês<br>
Calendar1.CalendarDate := CalendarDate - 1;// vai para um dia anterior<br>
Calendar1.CalendarDate := CalendarDate + 1;// vai para o proximo dia<br>
<br>

<p>Dias da semana<br>
var<br>
WeekDay : array[1..7] of string;<br>
DayNo : integer;<br>
QDay : string;<br>
begin<br>
weekday[1] := 'domingo<br>
weekday[2] := 'segunda';<br>
weekday[3] := 'ter‡a';<br>
weekday[4] := 'quarta';<br>
weekday[5] := 'quinta';<br>
weekday[6] := 'sexta';<br>
weekday[7] := 'sabado'; DayNo := DayofWeek(Date); // pega numero do dia da semana..<br>
// a mensagem exibe o valor do array na posi‡Æo n. da semana<br>
ShowMessage('O dia ‚: ' + WeekDay[DayNo]);<br>
<br>
Verificando os dígitoso do ano<br>
Function AnoQuatroDigitos: Boolean;<br>
begin<br><br>
Result := (Pos('yyyy',SHortDateFormat)>0);<br>
if Result = True then<br>
ShowMessage('O ano esta configurado para quatro dígitos.')<br>
else
ShowMessage('O ano não esta configurado para quatro dígitos.');<br>
end;<br>
<br>
&Trabalhando com Frames<br>
// No menu File>New, insira um TFrame.<br>
Declare em { Private declarations }<br>
FFrame: TFrame;<br>
// Dois botões usando a mesma variável do frame...<br>
// botão um..<br>
if FFrame <> nil then<br>
FFrame.Free;<br>
FFrame := TFrame1.Create(pnlParent);<br>
FFrame.Align := alClient;<br>
FFrame.Parent := pnlParent;<br>
<br>
// botão dois..<br>
if FFrame <> nil then<br>
FFrame.Free;<br>
FFrame := TFrame2.Create(pnlParent);<br>
FFrame.Align := alClient;<br>
FFrame.Parent := pnlParent;<br>
<br>
Jogar uma imagem direto para um campo na tabela<br>
var<br>
BMP : TBitMap;<br>
begin<br>
BMP := TBitmap.Create;<br>
if OpenPicutrueDialog1.Execute then<br>
begin<br>
BMP.LoadFromFile(OpenPictureDialog1.FileName);<br>
Table1Graphic.Assign(BMP);<br>
end;<br>
<br><br>
<b>#impressões</b><br>
O botão minimizar do quickReport.Alterar o arquivo Qrprev.dfm na pasta Lib.:<br>
BorderIcons = [biSystemMenu,biMaximize]<br>
<br>
<b>TPrinter</b><br>
//Uses Printers<br>
BiginDoc = inicia uma impressão<br>
EndDoc = finaliza uma impressão<br>
Abrot = interrompe a impressão<br>
Priting = para saber se esta havendo uma impressão<br>
printers = lista as impressoras instaladas<br>
PrinterIndex = indica a impessora selecionada<br>
Fonts = lista as fontes da impressora<br>
Orientation ( em Portrait ou LandScape) = orientação do papel<br>
PageHeight = Altura da página<br>
PageWidth = Largura da página<br>
PageNumber = Número da página atual<br>
exemplo:<br>
Procedure TForm1.Button1Click(Sender: TObject);<br>
var Arquivo : TextFile;<br>
begin<br>
AssignFile(Arquivo,'LPT1');<br>
Rewrite(Arquivo);<br>
Writeln(Arquivo,'Teste de impressao - Linha 0');<br>
Writeln(Arquivo,'Teste de impressao - Linha 1');<br>
Writeln(Arquivo,#27#15+'Teste de Impressão - Linha 2');<br>
Writeln(Arquivo,'Teste de impressao - Linha 3');<br>
Writeln(Arquivo,#27#18+'Teste de Impressão - Linha 4');<br>
Writeln(Arquivo,'Teste de impressao - Linha 5');<br>
Writeln(Arquivo,#12); // Ejeta a página<br>
CloseFile(Arquivo);<br>
end;<br>
<br>
<h1>#internet</h1>
<p>Para executar um página da Web I<br />
Winexec ( 'start c:\windows\index.html',sw_ShowMinimized )</p>

<p>Para executar um página da Web II<br />
ShellExecute(Handle, 'open', HTMLFile, nil, nil, SW_SHOWNORMAL);<br />
Chamando um site utilizando o seu browse padrão. Coloque em USES:UrlMon;<br />
HlinkNavigateString(nil, 'http://www.geocities.com/escolarte');<br>
//Verificando se você está conectado a Internet<br>
//Inclua um componente TCP no Form, e digite o código:<br>
if (TCP1.LocalIP = '0.0.0.0' or<br>
TCP1.LocalIP = '127.0.0.1') then<br>
ShowMessage('Não existe conexão')<br>
else<br>
ShowMessage('Existe Conexão')<br>

<h1># WebBrowser </h1>
<p>memo1.Text := WebBrowser1.OleObject.Document.documentElement.innerText;</p>
<p>memo1.Text := WebBrowser1.OleObject.document.Body.InnerHTML;</p>

<p>Imprimir sem caixa de diálogo:</p>
<pre>
procedure TForm1.Button2Click(Sender: TObject);
var
  vaIn, vaOut: OleVariant;
begin
  WebBrowser1.ControlInterface.ExecWB(
    OLECMDID_PRINT,
    OLECMDEXECOPT_DONTPROMPTUSER,
    vaIn, vaOut);
end;
</pre>

<p>Imprimir com caixa de diálogo:</p>
<pre>
procedure TForm1.Button3Click(Sender: TObject);
var
  vaIn, vaOut: OleVariant;
begin
  WebBrowser1.ControlInterface.ExecWB(
    OLECMDID_PRINT,
    OLECMDEXECOPT_PROMPTUSER,
    vaIn, vaOut);
end;
</pre>

<p>Pré visualização de impressão:</p>
<pre>
procedure TForm1.Button4Click(Sender: TObject);
var
  vaIn, vaOut: OleVariant;
begin
  WebBrowser1.ControlInterface.ExecWB(
    OLECMDID_PRINTPREVIEW,
    OLECMDEXECOPT_DONTPROMPTUSER,
    vaIn, vaOut);
end;
</pre>

<p>Configuração da impressão:</p>
<pre>
procedure TForm1.Button5Click(Sender: TObject);
var
  vaIn, vaOut: OleVariant;
begin
  WebBrowser1.ControlInterface.ExecWB(
    OLECMDID_PAGESETUP,
    OLECMDEXECOPT_PROMPTUSER,
    vaIn, vaOut);
end;
</pre>



<h2>Pegar o conteúdo de uma página html:</h2>
<pre>
procedure TForm1.Button1Click(Sender: TObject);
 Const
   LINK = 'http://www.xxx.com.br/teste.php?Teste';
begin
   IdHTTP1.HandleRedirects := True;
   IdHTTP1.Request.UserAgent := 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0';
   Memo1.Text := IdHTTP1.Get(LINK);
end;
</pre>

<p>Ver se a pagina existe</p>
<pre>
procedure TForm1.Button1Click(Sender: TObject);
var
  http : TIdHttp;
  url : string;
  codigo : integer;
begin
  url := 'http://www.xxx.com.br/teste.php?Teste';
  http := TIdHTTP.Create(nil);
  try
    try
      http.Head(url);
      codigo := http.ResponseCode;
    except
      on E: EIdHTTPProtocolException do
        codigo := http.ResponseCode;
    end;
    ShowMessage(IntToStr(codigo));
  finally
    http.Free();
  end;
</pre>

<p>Caracteres especiais</p>
<p>UTF8Encode(); <br />
UTF8Decode();</p>
<p>Exemplos:<br />
Memo1.Lines.Text := UTF8Decode(WebPageContent); <br />
Memo1.Lines.LoadFromFile('C:\arquivo.txt',TEncoding.UTF8);</p>


<h1>Usando o IBX:</h1>
<p>Usarei como o nome do servidor onde está instalado o INTERBASE<br />
"SERVER_IB"<br>
O banco de dados estará instalado no path<br>
"C:\IB_DB\GUESTS.GDB" o caminho c:\ib_db\guests.gdb REFERE-SE A UNIDADE C: DO SERVIDOR.<br>
<br>
Arquivo Hosts.sam<br>
<br>
Procure o arquivo HOSTS.SAM no diretório windows das máquinas clientes:<br>
Caso o ip do servidor seja 192.198.25.4 então coloque em uma linha do arquivo hosts.sam 192.198.25.4 SERVIDOR
No componente TIBDatabase, propriedade DatabaseName coloque:<br>
SERVER_IB:C:\IB_DB\GUESTS.GDB<br>
Informe na propriedade PARAMS do TIBDATABASE as seguintes strings:<br>
user_name = SYSDBA<br>
password=masterkey<br>
. atribua para FALSE a propriedade LOGIN PROMPT<br>
Coloque um TIBTransaction e na propriedade DefaultTransaction do TIBDatabase atribua ao componente TIBTransaction.
clique no componente TIBTransaction e na propriedade DEFAULTDATABASE coloque o TIBDATABASE.<br>
agora dê um clique duplo no componente TIBTransaction e sete o nível de transação para READ COMMITED e retire o parâmetro no wait ( para não acontecer o dead lock em caso de multiplas edições do registro )
<br>
<br>
Conectando a um servidor LINUX<br>
A entrada no arquivo HOSTS.SAM é a mesma ex: 10.0.0.2 SERVER_LINUX<br>
#SERVIDOR LINUX Apenas você terá que mudar o path do arquivo GDB. A string é case sensitive o Linux não usa letras de drives para conexão
ex: SERVER_LINUX:/var/ib_db/guests.gdb<br>
<hr />

Delete(vS, 2,1); <i>// delete da variável vS, na segunda posição, 1 caractere</i><br />
Insert("z",vS,1); <i>//insere a letra z no começo da string</i><br>
Length(vS); <i>Retorna o número de caracteres de uma string</i><br>
Lowercase( 'SORTE' ); <i>// tranformar para 'sorte'</i><br>
UpperCase( 'sorte' ); <i>// tranformar para 'SORTE'</i><br>
Pos('a','Pernambuco'); <i>// retorna a posição de uma string dentro de uma outra string. valor 5</i><br>
Str(vN,vS); <i>//Converte um valor inteiro ou real(vN)para uma string(vS)</i><br>
VAL - Esta rotina extrai o valor numérico ( tipo real ou integer ) de uma String;<br>
Sua sintaxe é :<br>
Val ( S ; var v ; var Code : integer );<br>
Observe o exemplo abaixo :<br>
Var<br>
N, C : integer ;<br>
Begin<br>
Val ( Edit1.Text, N, C ) ;<br>
Button1. Top := N ;<br>
End ;<br>
// Se a variável C tiver valor diferente de 0 significa que ouve erra na conversção. ( ex : O texto do Edit não é um número intéiro válido )<br>
<br>
Format<br>
//Para coloca zeros a esquerda dos números encontrados.
%5 o valor da variável inteira "VNum"
// .5d por que são 5 caracteres
Edit1.text:= Format('%5.5d',[VNum]);
<br>
//Colocar zeros a esquerda de um valor inteiro digitado no Edit<br>
Edit1.Text := FormatFloat('000000',StrToInt(Edit1.Text));<br>
Formatando com estilo de moeda
//Formatando um valor Real
Edit1.Text := FormatFloat('#,##0.00',vSalario);
//Formatando uma String
Edit1.Text := FormatFloat('#,##0.00',StrToFloat(Edit1.Text));
Obs- (#) Cerquilha, para números obcionais. (,) Ponto para separar milhar. (.) Virgula para separar casas decimais.
<br>
//A linha abaixo exibe em um label, seu top. Misturando String do Inteiro
Label1.Caption := Format('O top deste label é %d',[Label1.top]);
//Lendo uma variável inteira
Label.Caption := Format ('O número guardado é : %d, [i]);
// Para exibir o valor Hexadecimal de uma variável integer(i)
Label1.Caption := Format('$%x',[i]);
//Formatando uma Data:
dbedit1.text:=formatDateTime('dd/mm/yyyy hh:mm',now);
<br>
&Delete - Ex:
Delete(MyString) // deleta da variável MyString, na segunda posição, um caractere
Insert - Ex:
Insert ('z',MyString,1) // Insere a letra z no começo da String
InttoStr - Ex:
MyString := InttoStr(Shape1.top)<i>//A variável MyString recebe o valor top do componente Shape1</i><br>

INPUTBOX<br>
<i>//Exibe uma caixa de diálogo onde digitamos um valor que será exibido em um label</i><br>
Label1.Caption := InputBox('digite','integer','');<br>
<br>
<i>//Sensível à maiúsculas e minúsculas. Veja abaixo dois exemplos.</i><br>
Exemplo1<br>
procedure TForm1.Button3Click(Sender: TObject);<br>
var<br>
NS: string;<br>
clickOK: Boolean; // clickok foi inventado<br>
begin<br>
NS := 'Nome fixo';<br>
Label1.Caption := NS;<br>
clickOK := InputQuery('Input Box', 'digite', NS);<br>
if clickOK then<br>
Label1.Caption := 'The new string is ''' + NS + '''';<br>
end;<br>
<br>
&INPUTQUERY<br>
inputQuery( ' ver ' , ' senha ' , r );<br>
<br>
&Tratando Erros<br>
Deletando um registro<br>
try<br>
DMAgenda.tbAgenda.Delete;<br>
except<br>
On E:EDBEngineError do<br>
ShowMessage('Registro em uso por outro USUÁRIO. Exclusão Cancelada';<br>
end;<br>

Centralizar um componete<br>
No evento OnResize digite:<br>
Toda vez que o form sor redimencionado, o Button ficara no centro<br>
Button1.Top := Form1.ClientHeight div 2 - Button1.Height div 2;<br>
Button1.Left := Form1.ClientWidth div 2 - Button1.Width div 2;<br>
<br>

<b>Senhas</b><br>
Colocar senha numa tabela Paradox //...e retirar em tempo de execução:<br>
Session.AddPassword('Senha-Da-Tabela');<br>
...<br>
Session.RemovePassword;<br>
outra opção...<br>
Session.AddPassword('Senha');<br>
Table1.Active := True;<br>
// vincule o Table1 ao Session><br>
<br>

findfield<br>
Contador : Integer;//colocar em na área var ou uses<br>
var // no evento onClick do botão OK<br>
s : TstringField; //unit db<br>
begin
s:= DataModlule1.Table1.findfield('senha')as TstringField; // procura na coluna senha<br>
if s.value <> Edit1.text then<br>
begin<br>
ShowMessage('senha invalida');<br>
inc(contador);<br>
if Contador = 3 then<br>
begin<br>
ShowMessage('vc teve 3 chances');<br>
formPrincipal.Close;<br>
end;<br>
exit;<br>
formSenha.Close;<br>
formPrincipal.Enabled := true;<br>
end;<br>
<br>
<b>// Cográfico</b><br>
Grafic1.Title.Text.Clear<br>
Grafic1.Title.Text.Add('Alunos por sexo');<br>
With Series1 do<br>
Begin<br>
  Add( 40, 'Pencil' , clRed ) ;<br>
  Add( 60, 'Paper', clBlue ) ;<br>
  Add( 30, 'Ribbon', clGreen ) ;<br>
end;<br>
<br>

%DIA DA SEMANA<br>
<i>Retorna o dia da semana em um inteiro de 1 a 7.</i><br>
function DayOfWeek(Data:TDataTime):Integer;<br>
<i>Data e Hora Atual</i><br>
Ex.:Label1.Caption:= 'Data e Hora Atual' + DateTimeToStr(Now);<br>
<br>
O form - Métodos e Propriedades do Form<br>
{ para um formulário aparecer sobre outros sempre }<br>
Form1.formstyle := fsOntop;<br>
<i>{texto em um form}</i><br>
canvas.textout(0,0,'Este texto aparece no form. Top e Left zerados');<br>
<i>{form Elíptico}</i><br>
No evento OnCreate do form, digite:<br>
var hR : THandle;<br>
begin<br>
<br>
Cria uma form de formato elíptico<br>
Obs. Também é bom alterar a propriedade BorderStyle para bsNone. O tamanho da elípse é definido pelo tamanho do form.<br>
hR := CreateEllipticRgn (0,0,Width,Height);<br>
SetWindowRgn (Handle,hR,True);<br>
end;<br>
<br>
Evitar que se tente abrir o mesmo Form, duas vezes<br>
if form1 = nil then // se o form1 ainda não foi criado...<br>
... comandos para criar um form...<br>
//colocar no evento OnClose:<br>
form1 := nil;
<br>
&WINEXEC<br>
<i>//Para executar um outro aplicativo apartir do Delphi</i><br>
If Winexec('c:\windows\calc.exe',sw_shownormal)= 2 then<br>
  showmessage('Arquivo não encontrado');<br>
<br>
<i>//usados no botão fechar dos programas</i><br>
If (fileexists(PChar(vPathName + 'BackUp.exe'))) then<br>
  Winexec(PChar(vPathName + 'BackUp.exe'),SW_SHOWNORMAL);<br>
<br>
<i>//Para executar um página da Web</i><br>
Winexec ( 'start c:\windows\index.html',sw_ShowMinimized )<br>

<p>Usando o Repeat</p>
var<br>
N : String;<br>
begin<br>
Repeat;<br>
N := Inputbox('GetNumber', 'Insira um número','');<br>
Until N:= '7';<br>
end;<br>
Atribuir Mesmo Valor para Vários Edits em um Form<br>
for i := 0 to ComponentCount - 1 do<br>
if Components[i] is TEdit then<br>
TEdit(Components[i]).Text := Valor;<br>
<br>
Testa se há disco no Drive A:<br>
function TForm1.TemDiscoNoDrive(const drive : char): boolean;<br>
var<br>
DriveNumero : byte;<br>
EMode : word;<br>
begin<br>
result := false;<br>
DriveNumero := ord(Drive);<br>
if DriveNumero >= ord('a') then<br>
dec(DriveNumero,$20);<br>
EMode := SetErrorMode(SEM_FAILCRITICALERRORS);<br>
try<br>
if DiskSize(DriveNumero-$40) <> -1 then<br>
Result := true else messagebeep(0);<br>
finally<br>
SetErrorMode(EMode);<br>
end;<br>
end;<br>
<br>
procedure TForm1.Button1Click(Sender: TObject);<br>
begin<br>
if TemDiscoNoDrive('a') then<br>
ShowMessage('Tem disco no drive A:')<br>
else ShowMessage('Não tem disco no drive A:');<br>
end;<br>
<br><br>
Close em um Form<br>
OnCloseQuery //No evento OnCloseQuery. A segunda opção ("Não") recebe o foco.<br>
CanClose := Application.MessageBox( 'Confirme Operação','Terminar Aplicação ?',<br>
MB_ICONQUESTION + MB_YESNO + MB_DEFBUTTON2 ) = ID_YES;<br>
<br>
Salvar dados antes de fechar:<br>
//no evento OnClose:<br>
if Table1.Modified then<br>
if Application.MessageBox('Gravar alterações?','Dados Alterado',MB_ICONQUESTION + MB_YESNO) = IDYES then<br>
Table1.Post<br>
else<br>
Table1.Cancel<br>
<br>
Obtendo o número serial do HD<br>
Function SerialNum(FDrive:String) :String;<br>
Var<br>
Serial:DWord;<br>
DirLen,Flags: DWord;<br>
DLabel : Array[0..11] of Char;<br>
begin<br>
Try<br>
GetVolumeInformation(PChar(FDrive+':\'),dLabel,12,@Serial,DirLen,Flags,nil,0);<br>
Result := IntToHex(Serial,8);<br>
Except<br>
Result :='';<br>
end;<br>
end;<br>

Criando Tabelas<br>
Através da função FieldDefs.ADD. Parâmetros: nome do campo, tipo, Tamanho, Chave_Primária.<br>
Procedure Cria_Tabela(Alias,Nome_Tabela:String);<br>
Begin<br>
With TTable.Create(Application) do<br>
begin<br>
Active := False;<br>
DatabaseName :=Alias;<br>
TableName := Nome_Tabela;<br>
TableType := ttDefault;<br>
FieldDefs.Add('CODCLI', ftString, 5, False);<br>
FieldDefs.Add('NOMCLI', ftString, 40, False);<br>
FieldDefs.Add('DATCAD', ftDate, 0, False);<br>
CreateTable;<br>
Free;<br>
end;
end;

Como Usar:<br>
procedure TForm1.Button1Click(Sender: TObject);<br>
begin<br>
Cria_Tabela('C:\Temp','Alunos.db');<br>
end;<br>

LOCALIZAR<br>
//nesta caixa de diálogo, o campo nome tem que ser o primeiro<br>
var // uma variárvel tem que ser criada.<br>
nome : string;<br>
Nome : = inputbox( ' Localizar ' , ' digite o nome ' , ' ' ) ;<br>
if nome <> ' ' then<br>
begin<br>
if not table1.findkey ( [ nome ] ) then<br>
showmessage ( ' nome não encontrado ' ) ;<br>
end;<br>
Simplificando: Table1.findkey([edit1.text])<br>
<br>
ou<br>
table1.setkey;<br>
table1.fields[0].AsString := Edit1.text;<br>
Table1.GotoKey;<br>
<br>
Apenas a linha abaixo :<br>
Table1.FindKey([Edit1.Text]);<br>
Apenas a linha abaixo :<br>
Table1.FindNearest([Edit1.Text]);<br>
Table1.SetKey; // Primeiro campo é a chave<br>
Table1.FieldName('Cidade') := Edit1.Text;<br>
Table1.GotoKey;<br>
<br>
Table1.IndexName := 'NomeCliente'; // procurar em um índice secundário<br>
Table1.Open;<br>
Table1.SetKey;<br>
table1NomeCliente.AsString := Edit1.Text;<br>
Table1.GotoNearest;<br>
.<br>
// Procurar em um índice primário ou secundário<br>
Table1.IndexName := 'Nome'<br>
Table1.Open;<br>
Table1.SetKey;<br>
Table1Nome_Cliente.AsString := Edit1.Text;<br>
Table1.GotoNearest;<br>
<br>
Locate// procura em um índice primário ou secundário<br>
Table1.Locate('Nome',Trim(Edit1.text),[LoPartialKey,loCaseInsensitive]);<br>
if not DM.Table1.Locate('Vendedor;Data',VarArrayOf([EditVendedor.text, EditData.text]),[loCaseInsensitive]) then<br>
ShowMessage('O vendedor não realizou venda nesa data');<br>
<br>
FindKey<br>
//Procura um nome em um campo. ( no primeiro campo ).<br>
// No evento OnClick do Botão Ok, digite<br>
begin<br>
if not DataModule.tsenha.FindKey ( [ editNome.text ] ) then<br>
beguin<br>
ShowMessage ( ' senha desconhecida ' );<br>
Exit;<br>
end ;<br>
<br>
&EXCEPTIONS - Exceções<br>
Access violation<br>
Decrare a constante:<br>
const<br>
ChaveViolada = 9729;
No evento OnPostError da tabela, digite:<br>
if (E is EDBEngineError) then<br>
if (E as EDBEngineError).Error[0].Errorcode = ChaveViolada then<br>
begin<br>
Table1.Cancel;<br>
ShowMessage('este código já existe');<br>
end;<br>
abort<br>
<br>
Outras exceções<br>
if(E is EDBEngineError) then<br>
with EDBEngineError(E) do<br>
case Errors[0].ErrorCode of<br>
DBIERR_KEYVIOL: ShowMessage('Cliente já cadastrado.');<br>
DBIERR_REQDERR: ShowMessage('Campo obrigatório não preenchido.');<br>
end<br>
else<br>
ShowMessage('Erro no banco de dados:' + #13#13 + E.Message);<br>
Action := daAbort;<br>
<br>
<b>construindo gráfico</b><br>
With Series1 do<br>
Begin<br>
  Add( 40, 'Pencil' , clRed ) ;<br>
  Add( 60, 'Paper', clBlue ) ;<br>
  Add( 30, 'Ribbon', clGreen ) ;<br>
end;<br>
<br>
Tirando Senha tabela paradox:<br>
Para PARADOX 7.0 -> "jIGGAe" ou "cupcdvum"<br>
Para PARADOX 5.0 -> "jIGGAe" ou "cupcdvum"<br>
Para PARADOX 4.0 (DOS) -> "nx66ppx"<br>
<br>
<hr>

<br>
%BOOKMARKS<br>
//guardar uma posição no registro<br>
var<br>
BM :tBookMark;<br>
{...}<br>
// Grava um Registro<br>
if bm = nil then // se bm está vazio então...<br>
bm := table1.GetBookMark; // marque um<br>
ou<br>
if BookMark = nil then<br>
BookMark := Table1.GetBookMark;<br>
{++}<br>
<br>
// ir para o registro guardado<br>
if BookMark <> nil then // se o BookMark não está vazio...<br>
begin<br>
table1.GotoBookMark(BookMark) // vá para o marcado<br>
end;<br>
ou..<br>
if BM <> nil then<br>
begin<br>
BM := table1.GetBookMark(BM);<br>
<br>
{++}<br>
//limpa da memória o registro guardado<br>
if BookMark <> nil then // se o BookMark não está vazio então faça..<br>
begin<br>
Table1.FreeBookMark (BookMark); // libere o marcado..<br>
BookMark := nil; // deixe-o vazio<br>
end;<br>
ou<br>
if bm <> nil then<br>
begin<br>
Table1.FreeBookMark (bm);<br>
bm := nil;<br>
end;<br>
// conjunto de comandos<br>
if BookMark < > nil then<br>
begin<br>
table1.GotoBookMark(BookMark);<br>
Table1.FreeBookmark(BookMark);<br>
BookMark := nil;<br>
end;<br>
<br>
<b>DBGrid</b><br>
Maiúsculo ou Minúsculo no DBGrid<br>
<i>//OnKeyPress do DBGrid:</i><br>
Key := AnsiUpperCase(Key)[1];<i>//ou</i><br>
Key := AnsiLowerCase(Key)[1];<br>
<br>
Cores do DBGRid<br>
Coloque a propriedade defaultdrawdata do dbgrid em FALSE<br>
No evento onDrawColumnCell coloque<br>
If QyTalPrazo.Value > DATE then<i> // condição </i><br>
begin<br>
Dbgrid1.Canvas.Font.Color:= clFuchsia; <i>// coloque aqui a cor desejada</i><br>
DBGrid1.Canvas.Brush.Color:= clAqua;<br>
DBGrid1.Canvas.FillRect(Rect);<br>
DBGrid1.DefaultDrawColumnCell(Rect, DataCol, Column, State);<br>
end;<br>
<br>
++++++++

Soma<br>
// RecordCount, conta quantos registros ha na Tabela<br>
Label1.Caption := InttoStr(Table1.Recordcount);<br>
<br>
Os estados de um Data Base<br>
if Table1.State = dsEdit then<br>
begin...<br>
Para saber o Estado de um DataBase. Digite no Evento OnStateChange do DataSourse:<br>
Var<br>
S : String; begin<br>
Case Table1.State of<br>
dsInactive : S := 'Inativo';<br>
dsBrownse : S := 'Browse';<br>
dsEdit : S := 'Edição';<br>
dsInsert : S := 'Inserção';<br>
dsSetKey : S := 'SetKey';<br>
dsCalcFields : S := 'CalkFields';<br>
end;<br>
Label1.Caption := S;<br>
<br>
<b>Para digitar só números em um edit</b><br>
if not (Key in['0'..'9',Chr(8)]) then Key:= #0;<i> //evento OnKeyPress</i><br>
<i>// Obs: Chr(8), para BackSpace e DecimalSeparator, para a vírgula dentro dos colchetes.</i></br>
<br>
Alias<br>
<br>
{Criando um alias I}<br>
Check(DBiAddAlias(Nil, Pchar('AliasName'),Nil, Pchar('AliasPath), true));<br>
AliasName = nome do alias;<br>
AliasPath = caminho do alias;<br>
Inclua em Uses = BDE e BD;<br>
<br>
{Criando Alias II}<br>
vPathName := ExtractFilePath (ParamStr (0));<br>
{ se o alias não existir... }<br>
if not Session1.IsAlias('Infocad') then<br>
begin<br>
{ Adiciona o alias }<br>
Session1.AddStandardAlias('Infocad', vPathName, 'PARADOX');<br>
{Salva o arquivo de configuração do BDE }<br>
Session1.SaveConfigFile;<br>
end;<br>
<br>
{Criando um alias III}<br>
// Utilizando o componente TSession<br>
session1.ConfigMode:=cmSession;<br>
Session1.AddStandardAlias('NomedoAlias','C:\Arquivos de Programas\Arquivos comuns\Borland Shared\Data','PARADOX');
<br>
Atualizando as informações em ambiente de rede<br>
Acessando a mesma tabela concorrente com outra estação ou outro objeto Query, Table<br>
a) Crie procedure para uso no evento OnActive:<br>
Procedue TTorm1.FormRefresh(Sender: TObject);<br>
begin<br>
Table1.Refresh;<br>
...<br>
TableN.Refresh;<br>
end;<br>
b)No evento OnActive do formulário acrescente a linha:<br>
Application.OnActive := FormRefresh;<br>
c) No evento OnShow do formulário acreste a linha<br>
FormRefresh(Sender);<br>
d) No evento OnAfterPost de cada objeto TTable acrescente as linhas;<br>
Table.FlushBuffer;<br>
FormRefres(Self);<br>
<br>
&Salvando Dados Fisicamente em uma Tabela<br>
USES DBIProcs;<br>
Nos eventos OnAfterPost e OnAfterDelete, digite:<br>
DBISaveChanges(Table1.handle);<br>
Salvando Os dados Visicamente II<br>
USES BDE:<br>
DbiSaveChandges((Dataset as TTable).Handle);<br>
<br>
&DBNavigator<br>
//Para pegar o nome do botão que foi pressionado<br>
DBNavigator1.BtnClick(nbNext);<br>
// pegando o botão clicado<br>
if Button in [nbFirst,nbLast,nbPrior,nbNext] then<br>
DBNavigator.DataSource.DataSet.Refresh;<br>
<br>
<hr />

&Imagem no Form<br>
Colocar uma figura bmp, no form sem o Picture<br>
var<br>
BitMap : TBitMap;<br>
Begin<br>
BitMap : = TBitMap.Creat ;<br>
With BitMap do<br>
Biguin<br>
LoadFromFile( ' c : \ figura . bmp' ) ;<br>
Transparent := true ;<br>
Form1. Canvas . Draw (50,50, bitMap);<br>
end:<br>
end;<br>
//Desktop, imagem no form<br>
//Procedure TForm E. FormResize(Sender: tobject);<br>
Var<br>
R : TRect ;<br>
DC : HDc ;<br>
Canv : TCanvas ;<br>
Begin<br>
R : = Rect (0,0, Screen.Width, Screen.Height);<br>
DC : = GetWindowDC (GetDeskTopWindow);<br>
Canv := TCanvas.Create;<br>
Canv . Handle := DC;<br>
Canvas . CopyRect(R,Canv,R);<br>
ReleaseDC (GetDeskTopWindow, DC);<br>
end;<br>
<br>
CopyFile, para copiar arquivos<br>
CopyFile(pchar('c:\conto.txt'),('a:\conto.txt'),false);<br>
// no final: true=não regrava o arquivo, se false, ele regrava.<br>
<br>
A Tecla Pressionada<br>
//No evento OnKeyDown, digite:<br>
Label1.Caption := Format('O código da tecla é: %d', [Key]);<br>
<br>
O componente TMediaPlayer<br>
Para ouvir um som<br>
With MediaPlayer1 do<br>
begin<br>
FileName := 'c:\bettoven.wav'; // pode ser um Mid<br>
Open;<br>
Play;<br>
end;
<br>
Para ver um *.avi no form...<br>
with MediaPlayer1 do
begin<br>
FileName := 'c:\super.avi';<br>
Open;<br>
Display := Form2;<br>
Form2.Show;<br>
Play;<br>
end;<br>
<br>
Arquivos RichEdit<br />
Carregando o texto em um RichEdit<br>
RichEdit1.Lines.LoadFromFile('c:\aviso.txt');<br>
//colocando cores<br>
ReachEdit1.Font.Color := clGreen;<br>
Estilos de Texto<br>
//testo em negrito<br>
if CheckNegrito.Checked then //Para o botão Negrito<br>
Memo1.Font.Style := Memo1.Font.Style + [fsBold] // coloca em estilo negrito<br>
else<br>
Memo1.Font.Style := Memo1.Font.Style - [fsBold]; // retira o estilo negrito<br>
//Memo1.Font.Style := Memo1.Font.Style + [fsItalic] // Para o botão Itálicov
//Memo1.Font.Style := Memo1.Font.Style + [fsUnderline] // Para o botão Sublinhado<br>
<br>
//testo em negrito II<br>
if BoldButton.Down then<br>
CurrText.Style := CurrText.Style + [fsBold]<br>
else<br>
CurrText.Style := CurrText.Style - [fsBold];<br>
end;<br>
function TMainForm.CurrText: TTextAttributes;<br>
begin
if Editor.SelLength > 0 then Result := Editor.SelAttributes<br>
else Result := Editor.DefAttributes;<br>
end;<br>
<br>
Alinhamento do texto<br>
{taLeftJustify, taCenter, taRightJustify}
Label1.Alignment := taLeftJustify;<br>
<br>

Movimento<br>
fazer um panel ter seu texto em movimento<br>
var<br>
texto : string;<br>
begin<br>
texto : = panel1.caption;<br>
panel1.caption := copy(texto,2,length (texto)) + texto[1];<br>
end;<br>
<br>
ColorGrid<br>
Form1.Color := ColorGrid1.ForegroundColor ; //botão esquerdo do mouse<br>
Form1.Color := ColorGrid1.BackgroundColor ;// botão direito do mouse<br>
<br>
Movendo Arquivos<br>
var<br>
origem, destino : string;<br>
begin<br>
origem := 'c:\delete\faq.txt';<br>
destino:= 'c:\games\faq.txt';<br>
if not copyfile(pchar(origem),pchar(destino),true) then<br>
showMessage ( 'problemas com' + origem + 'para' + destino)<br>
<br>
MOVENDO UM OBJETO<br>
// Coleque em um objeto ( ex: um Button)<br>
// Na guia VAR, digite<br>
MouseDownSpot : TPoint;<br>
Capturing : bool;<br>
// No evento OnMouseDown<br>
SetCapture(Button1.Handle);<br>
Capturing := true;<br>
MouseDownSpot.X := x;<br>
MouseDownSpot.Y := Y;<br>
// No evento OnMouseMove<br>
if Capturing then<br>
begin<br>
Button1.Left:= Button1.Left-(MouseDownSpot.x -x);<br>
Button1.Top:= Button1.Top - (MouseDownSpot.y -y);<br>
end;<br>
// No evento OnMouseUp<br>
if Capturing then<br>
begin<br>
ReleaseCapture;<br>
Capturing := false;<br>
Button1.Left := Button1.Left - (MouseDownSpot.x -x);<br>
Button1.Top := Button1.Top - (MouseDownSpot.y - y);<br>
end;<br>
<br>
Arquivos Help<br>
// digite a linha abaixo para chamar um arquivo help<br>
WinHelp(Form1.handle, 'c:\Ajuda.hlp', HELP_CONTENTES,0);<br>
<br>
&Randomize<br>
//A linha de comando abaixo faz o label exibir aleatóriamente um número de 1 a 100<br>
Label1.Caption := InttoStr(Random(100));<br>
<br>
&Hint<br>
//colocar no evento OnCreate do form principal..<br>
Application.HintColor := clYellow; // define a cor de todos os hints<br>
Application.HintPause := 200; // define o tempo de espera de um hint<br>
Edit1.hint := 'Primeira linha' + #13 + 'segunda linha';//Hint com quebra de linha<br>
<br>
&Criar um componente em tempo de execução<br>
var<br>
PictImg1 : TImage;//declarando um TImage<br>
begin<br>
PictImg1 := tImage.Create(self);<br>
PictImg1.Height := 200;<br>
pictImg1.Width := 200;<br>
PictImg1.Picture.LoadFromFile('C:\1.bmp');<br>
PictImg1.parent := Self;<br>
end;<br>
<br>
Cores com RGB<br>
//o form abaixo recebe a cor composta por:" red, green e blue"<br>
Form1.Color := Rgb(100, 100, 100);<br>
<br>
&Progess Bar<br>
Criando um ProgressBar em tempo de execução<br>
//Declare a procedure abaixo<br>
procedure TestProgress(Form: TForm; Count: SmallInt);<br>
var<br>
ProgressBar1: TProgressBar;<br>
i: SmallInt;<br>
begin
ProgressBar1 := TProgressBar.Create(Form);<br>
try<br>
ProgressBar1.Parent := Form;<br>
ProgressBar1.Align := alBottom;<br>
ProgressBar1.Min := 0;<br>
ProgressBar1.Max := Count;<br>
ProgressBar1.Step := 1;<br>
for i := 1 to Count do<br>
ProgressBar1.Stepit;<br>
ShowMessage('Now the ProgressBar control will be freed');<br>
finally<br>
ProgressBar1.Free;<br>
end;<br>
end;<br>
Finalmente, facha a chamada para o ProgessBar...<br>
TestProgress(Self, 1000);<br>
form2.show;<br>
<br>
O Componente TCalendar<br>
Calendar1.PrevYear;//para exibir o ano anterior<br>
Calendar1.NextYear;//para exibir o proximo ano<br>
Calendar1.PrevMonth;//para exibir o mês anterior<br>
Calendar1.NextMonth;//para exibir o próximo mês<br>
Calendar1.CalendarDate := CalendarDate - 1;// vai para um dia anterior<br>
Calendar1.CalendarDate := CalendarDate + 1;// vai para o proximo dia<br>
<br>

Verificando os dígitoso do ano<br>
Function AnoQuatroDigitos: Boolean;<br>
begin<br><br>
Result := (Pos('yyyy',SHortDateFormat)>0);<br>
if Result = True then<br>
ShowMessage('O ano esta configurado para quatro dígitos.')<br>
else
ShowMessage('O ano não esta configurado para quatro dígitos.');<br>
end;<br>
<br>
&Trabalhando com Frames<br>
// No menu File>New, insira um TFrame.<br>
Declare em { Private declarations }<br>
FFrame: TFrame;<br>
// Dois botões usando a mesma variável do frame...<br>
// botão um..<br>
if FFrame <> nil then<br>
FFrame.Free;<br>
FFrame := TFrame1.Create(pnlParent);<br>
FFrame.Align := alClient;<br>
FFrame.Parent := pnlParent;<br>
<br>
// botão dois..<br>
if FFrame <> nil then<br>
FFrame.Free;<br>
FFrame := TFrame2.Create(pnlParent);<br>
FFrame.Align := alClient;<br>
FFrame.Parent := pnlParent;<br>
<br>
Jogar uma imagem direto para um campo na tabela<br>
var<br>
BMP : TBitMap;<br>
begin<br>
BMP := TBitmap.Create;<br>
if OpenPicutrueDialog1.Execute then<br>
begin<br>
BMP.LoadFromFile(OpenPictureDialog1.FileName);<br>
Table1Graphic.Assign(BMP);<br>
end;<br>
<br><br>
<b>#impressões</b><br>
O botão minimizar do quickReport.Alterar o arquivo Qrprev.dfm na pasta Lib.:<br>
BorderIcons = [biSystemMenu,biMaximize]<br>
<br>
<b>TPrinter</b><br>
//Uses Printers<br>
BiginDoc = inicia uma impressão<br>
EndDoc = finaliza uma impressão<br>
Abrot = interrompe a impressão<br>
Priting = para saber se esta havendo uma impressão<br>
printers = lista as impressoras instaladas<br>
PrinterIndex = indica a impessora selecionada<br>
Fonts = lista as fontes da impressora<br>
Orientation ( em Portrait ou LandScape) = orientação do papel<br>
PageHeight = Altura da página<br>
PageWidth = Largura da página<br>
PageNumber = Número da página atual<br>
exemplo:<br>
Procedure TForm1.Button1Click(Sender: TObject);<br>
var Arquivo : TextFile;<br>
begin<br>
AssignFile(Arquivo,'LPT1');<br>
Rewrite(Arquivo);<br>
Writeln(Arquivo,'Teste de impressao - Linha 0');<br>
Writeln(Arquivo,'Teste de impressao - Linha 1');<br>
Writeln(Arquivo,#27#15+'Teste de Impressão - Linha 2');<br>
Writeln(Arquivo,'Teste de impressao - Linha 3');<br>
Writeln(Arquivo,#27#18+'Teste de Impressão - Linha 4');<br>
Writeln(Arquivo,'Teste de impressao - Linha 5');<br>
Writeln(Arquivo,#12); // Ejeta a página<br>
CloseFile(Arquivo);<br>
end;<br>
<br>

<hr />
Usando o Interbase<br>
Como colocar sua aplicação em rede com o Interbase x Delphi<br>
Instale o INTERBASE CLIENT nas estações<br>
<br>
Usando o IBX:<br>
Usarei como o nome do servidor onde está instalado o INTERBASE<br>
"SERVER_IB"<br>
O banco de dados estará instalado no path<br>
"C:\IB_DB\GUESTS.GDB" o caminho c:\ib_db\guests.gdb REFERE-SE A UNIDADE C: DO SERVIDOR.<br>
<hr />

<h1>Verificar se o programa ja estrá aberto</h1>
<p><i>Coloque o código abaixo no seu DPR.</i></p>
<pre>
Program Project1;

uses
  Forms,
  Windows,
  Dialogs, //não esqueça de declarar esta uses
Unit1 in 'Unit1.pas' {Form1};

{$R *.RES}

begin
  CreateMutex(nil, False, 'Nota10');
  if GetLastError() = ERROR_ALREADY_EXISTS then
  begin
    MessageBeep(MB_ICONERROR);
    MessageDlg('Este aplicativo já está sendo executado!', mtError, [mbOK], 0);
    Halt(0);
  end;

Application.Initialize;
Application.Title := 'Nota10';
Application.CreateForm(TForm1, Form1);
Application.Run;
end.
</pre>
<hr />

<h1><a name="config"></a> Configurações no Delphi </h1>
<p> Mudar os diretórios para o executável e para os arquivos dcu <br>
Vá no menu Project –> Options <br>
“Output directory“ = bin <br>
“Unit output directory“ = dcu </p>

<h1>Atalhos</h1>
<p>
Ctrl + shift + A  = encontrar unites relacionadas ao comp q vc inseriu<br />
Ctrl + shift + C  = Declare uma procedure ou funcion e ele cria o campo para digitação na unit<br />
</p>

<h1><a name="instala"></a> Instalando componentes</h1>

<p>Instalando componente <b> .pas </b></p>

<p> Feche qualquer projeto aberto projeto,<br> 
acesse: 'Component' + 'install component'. <br>
Na janela que se apresenta, marque: 'Into New Packages', <br>
clique no botão 'Browse' ao lado da caixa de texto 'Unit File Name' abra o arquivo com extensão *.pas, dê ok <br>
logo após 'Compile' e 'Install' e o arquivo criará uma aba na barra de componentes com um nome para a sua localização.<br>
No final: <br>
Tools + Options + Linguages + Delphi Option + Library <br />
Alterar o campo Library Path. (acrescentar o path)  <br />
</p>

<p>
  Feche o projeto aberto.<br>
  component + install component 	<br />
  Na janela, install component	<br />
- Pego um packaet já existente. Install into an existing package	<br />
- Abrir o arquivo .pas	<br />
- Associa ao pacote ja´existente	<br />
- Depois de compilado, vai avisar.	<br />
Tools + Options + Linguages + Delphi Option + Library	<br />
Alterar o campo Library Path. (acrescentar o path)	<br />
+ Salvar o pacote no final	
</p>

<pre>
Renomei o Package
Clicar em Add e adicionar o .pas
Depois em Install
Ponha o arquivo .dcu gerado e coloque na pasta lib
</pre>

<p>Instalar um componente no Delphi 2010</p>
<p>File --> New Package<br />
Adicione a Unit nesse pacote e salve o mesmo com o nome que quiser.<br />
Feche tudo e abra o DPK gerado. Voce tera que ter a opção Project Manager aberta para poder concluir a instalação (View --> Project Manager).<br />
Nessa tela, ira ter o .bpl, só clicar em build e depois install. Não esqueça de adicionar o caminho na Library Path após isso.<br />
</p>

<h1>Zeos </h1>
<p> Colocar na pasta lib a pasta com o nome zeos.<br>
abri e instala o package: <b> ZeosDboDev.groupproj </b><br>
Eu tive problemas para edita detro de arquivos de programas <br>
Coloquei em: c:\delphi\zeos <br>
Depois, em: tools, options, library, infomrei todas as pastas que haviam na pastar <b>src </b><br>
</p>

</body>
</html>